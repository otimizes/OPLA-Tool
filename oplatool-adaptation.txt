package br.otimizes.oplatool.core.jmetal4.experiments.base;

import br.otimizes.oplatool.common.exceptions.JMException;
import br.otimizes.oplatool.core.jmetal4.core.Algorithm;
import br.otimizes.oplatool.core.jmetal4.core.SolutionSet;
import br.otimizes.oplatool.core.jmetal4.core.SolutionSet;
import br.otimizes.oplatool.core.jmetal4.database.Result;
import br.otimizes.oplatool.core.jmetal4.experiments.CommonOPLAFeatMut;
import br.otimizes.oplatool.core.jmetal4.experiments.EdCalculation;
import br.otimizes.oplatool.core.jmetal4.metaheuristics.nsgaII.NSGAII;
import br.otimizes.oplatool.core.jmetal4.operators.crossover.Crossover;
import br.otimizes.oplatool.core.jmetal4.operators.crossover.CrossoverFactory;
import br.otimizes.oplatool.core.jmetal4.operators.mutation.Mutation;
import br.otimizes.oplatool.core.jmetal4.operators.mutation.MutationFactory;
import br.otimizes.oplatool.core.jmetal4.operators.selection.Selection;
import br.otimizes.oplatool.core.jmetal4.operators.selection.SelectionFactory;
import br.otimizes.oplatool.core.jmetal4.problems.OPLA;
import br.otimizes.isearchai.learning.Moment;
import br.otimizes.oplatool.core.persistence.ExperimentConfigurations;
import br.otimizes.oplatool.core.persistence.Persistence;
import br.otimizes.oplatool.domain.OPLAThreadScope;
import br.otimizes.oplatool.domain.entity.Execution;
import br.otimizes.oplatool.domain.entity.Experiment;
import br.otimizes.oplatool.domain.entity.Info;
import br.otimizes.oplatool.domain.entity.objectivefunctions.ObjectiveFunctionDomain;
import br.ufpr.dinf.gres.loglog.Level;
import org.apache.log4j.Logger;
import org.springframework.stereotype.Service;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class NSGAIIOPLABase implements AlgorithmBase<NSGAIIConfigs> {

    private static final Logger LOGGER = Logger.getLogger(NSGAIIOPLABase.class);

    private final Persistence persistence;
    private final EdCalculation edCalculation;

    public NSGAIIOPLABase(Persistence persistence, EdCalculation edCalculation) {
        this.persistence = persistence;
        this.edCalculation = edCalculation;
    }

    private static String getPlaName(String pla) {
        int beginIndex = pla.lastIndexOf(File.separator) + 1;
        int endIndex = pla.length() - 4;
        return pla.substring(beginIndex, endIndex);
    }

    public void execute(NSGAIIConfigs experimentCommonConfigs) throws Exception {
        String[] plas = experimentCommonConfigs.getPlas().split(",");

        for (String xmiFilePath : plas) {
            String plaName = getPlaName(xmiFilePath);
            OPLA problem = AlgorithmBaseUtils.getOPLAProblem(experimentCommonConfigs, xmiFilePath);
            Result result = new Result();
            Experiment experiment = persistence.save(plaName, "NSGAII", experimentCommonConfigs.getDescription(), OPLAThreadScope.hashOnPosteriori.get());
            ExperimentConfigurations conf = new ExperimentConfigurations(experiment.getId(), "NSGAII", experimentCommonConfigs);
            persistence.save(conf);

            SolutionSet allRuns = new SolutionSet();
            Algorithm algorithm = getAlgorithm(problem, experimentCommonConfigs);
            if (experimentCommonConfigs.isLog())
                logInformation(xmiFilePath, experimentCommonConfigs, experimentCommonConfigs.getPopulationSize(), experimentCommonConfigs.getMaxEvaluations(),
                        experimentCommonConfigs.getCrossoverProbability(), experimentCommonConfigs.getMutationProbability());

            List<String> selectedObjectiveFunctions = experimentCommonConfigs.getOplaConfigs().getSelectedObjectiveFunctions();
            persistence.saveObjectivesNames(selectedObjectiveFunctions, experiment.getId());
            result.setPlaName(plaName);
            long[] time = new long[experimentCommonConfigs.getNumberOfRuns()];

            for (int runs = 0; runs < experimentCommonConfigs.getNumberOfRuns(); runs++) {

                long initTime = System.currentTimeMillis();
                SolutionSet resultFront = algorithm.execute();

                long estimatedTime = System.currentTimeMillis() - initTime;
                time[runs] = estimatedTime;

                resultFront = problem.removeDominated(resultFront);
                resultFront = problem.removeRepeated(resultFront);

                Execution execution = AlgorithmBaseUtils.getExecution(experimentCommonConfigs, result, experiment, selectedObjectiveFunctions, runs, resultFront, estimatedTime, persistence);
                allRuns = allRuns.union(resultFront);
                AlgorithmBaseUtils.saveHypervolume(experiment.getId(), execution.getId(), resultFront, plaName);
            }

            allRuns = problem.removeDominated(allRuns);
            allRuns = problem.removeRepeated(allRuns);

            AlgorithmBaseUtils.logAndSave(experimentCommonConfigs, plaName, result, experiment, allRuns, selectedObjectiveFunctions, persistence, edCalculation);

            if (Moment.POSTERIORI.equals(experimentCommonConfigs.getClusteringMoment())) {
                experimentCommonConfigs.getInteractiveFunction().run(allRuns);
            }
        }
    }

    private Algorithm getAlgorithm(OPLA problem, NSGAIIConfigs experimentCommonConfigs) throws JMException {
        Algorithm algorithm = new NSGAII(problem);
        algorithm.setInputParameter("populationSize", experimentCommonConfigs.getPopulationSize());
        algorithm.setInputParameter("maxEvaluations", experimentCommonConfigs.getMaxEvaluation());
        algorithm.setInputParameter("interactiveFunction", experimentCommonConfigs.getInteractiveFunction());
        algorithm.setInputParameter("maxInteractions", experimentCommonConfigs.getMaxInteractions());
        algorithm.setInputParameter("firstInteraction", experimentCommonConfigs.getFirstInteraction());
        algorithm.setInputParameter("intervalInteraction", experimentCommonConfigs.getIntervalInteraction());
        algorithm.setInputParameter("interactive", experimentCommonConfigs.getInteractive());
        algorithm.setInputParameter("clusteringMoment", experimentCommonConfigs.getClusteringMoment());
        algorithm.setInputParameter("clusteringAlgorithm", experimentCommonConfigs.getClusteringAlgorithm());

        HashMap<String, Object> parametersCrossover = new HashMap<>();
        parametersCrossover.put("probability", experimentCommonConfigs.getCrossoverProbability());
        parametersCrossover.put("numberOfObjectives", experimentCommonConfigs.getOplaConfigs().getNumberOfObjectives());
        Crossover crossover = CrossoverFactory.getCrossoverOperator("PLACrossoverOperator", parametersCrossover, experimentCommonConfigs);
        algorithm.addOperator("crossover", crossover);

        HashMap<String, Object> parametersMutation = new HashMap<>();
        parametersMutation.put("probability", experimentCommonConfigs.getMutationProbability());
        Mutation mutation = MutationFactory.getMutationOperator("PLAMutationOperator", parametersMutation, experimentCommonConfigs);
        algorithm.addOperator("mutation", mutation);

        Selection selection = SelectionFactory.getSelectionOperator("BinaryTournament", null);
        algorithm.addOperator("selection", selection);
        return algorithm;
    }

    private void logInformation(String pla, NSGAIIConfigs configs, int populationSize, int maxEvaluations, double crossoverProbability, double mutationProbability) {
        logPanel(pla, configs, populationSize, maxEvaluations, crossoverProbability, mutationProbability);
        logConsole(pla, populationSize, maxEvaluations, crossoverProbability, mutationProbability);
    }

    private void logPanel(String pla, NSGAIIConfigs configs, int populationSize, int maxEvaluations, double crossoverProbability, double mutationProbability) {
        configs.getLogger().putLog("\n================ NSGAII ================", Level.INFO);
        AlgorithmBaseUtils.putLogContext(pla, configs, populationSize, maxEvaluations, crossoverProbability, mutationProbability);
    }

    private void logConsole(String pla, int populationSize, int maxEvaluations, double crossoverProbability, double mutationProbability) {
        LOGGER.info("================ NSGAII ================");
        AlgorithmBaseUtils.logContext(pla, populationSize, maxEvaluations, crossoverProbability, mutationProbability, LOGGER);
        LOGGER.info("================ NSGAII ================");
    }
}

package br.otimizes.oplatool.architecture.representation;

import br.otimizes.isearchai.learning.MLElement;

import java.util.Collection;
import java.util.HashSet;

public class Comment extends Element {

    private String value;

    public Comment(String name, String typeElement) {
        super(name, null, typeElement, null, null);
        if (typeElement == null) super.setTypeElement("comment");
    }

    public Comment(String name) {
        super(name, null, "comment", null, null);
    }

    @Override
    public Collection<Concern> getAllConcerns() {
        return new HashSet<>();
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}

package br.otimizes.oplatool.architecture.representation;

import br.otimizes.isearchai.learning.MLElement;
import br.otimizes.oplatool.architecture.exceptions.ConcernNotFoundException;
import com.rits.cloning.Cloner;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.eclipse.uml2.uml.Interface;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Element representation
 *
 * @author edipofederle<edipofederle @ gmail.com>
 */
public abstract class Element implements Serializable, br.otimizes.isearchai.learning.MLElement {

    private static final long serialVersionUID = 4736685073967472613L;

    protected String id;
    private String name;
    private VariationPoint variationPoint;
    private Variant variant;
    private final Set<Concern> concerns = new HashSet<>();
    private Set<Comment> comments = new HashSet<>();
    private String typeElement;
    private String namespace;
    private boolean belongsToGeneralization;
    private boolean freezedByCluster = false;
    private String posX = "0";
    private String posY = "0";
    private String globalPosX = "0";
    private String globalPosY = "0";
    private String height = "0";
    private String width = "0";
    private boolean mandatory = true;
    private boolean isStatic;
    private boolean isFinal;

    public Element(String name, Variant variant, String typeElement, String namespace, String id) {
        setId(id);
        setName(name);
        setVariant(variant);
        setTypeElement(typeElement);
        setNamespace(namespace);
    }

    public Element deepCopy() {
        try {
            return this.deepClone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    private Element deepClone() throws CloneNotSupportedException {
        Cloner cloner = new Cloner();
        Element pkg = cloner.deepClone(this);
        cloner = null;
        return pkg;
    }

    public String getPosX() {
        return posX;
    }

    public void setPosX(String posX) {
        this.posX = posX;
    }

    public String getPosY() {
        return posY;
    }

    public void setPosY(String posY) {
        this.posY = posY;
    }

    public String getGlobalPosX() {
        return globalPosX;
    }

    public void setGlobalPosX(String globalPosX) {
        this.globalPosX = globalPosX;
    }

    public String getGlobalPosY() {
        return globalPosY;
    }

    public void setGlobalPosY(String globalPosY) {
        this.globalPosY = globalPosY;
    }

    public String getHeight() {
        return height;
    }

    public void setHeight(String height) {
        this.height = height;
    }

    public String getWidth() {
        return width;
    }

    public void setWidth(String width) {
        this.width = width;
    }

    public boolean isMandatory() {
        return mandatory;
    }

    public void setMandatory(boolean mandatory) {
        this.mandatory = mandatory;
    }

    public boolean isStatic() {
        return isStatic;
    }

    public void setStatic(boolean aStatic) {
        isStatic = aStatic;
    }

    public boolean isFinal() {
        return isFinal;
    }

    public void setFinal(boolean aFinal) {
        isFinal = aFinal;
    }

    public abstract Collection<Concern> getAllConcerns();

    public String getId() {
        return id;
    }

    public float getNumberId() {
        int minValue = Integer.MIN_VALUE;
        int maxValue = Integer.MAX_VALUE;
        int numberId = (this.getNamespace() + ":" + this.getTypeElement() +
                ":" + this.getName()).hashCode();
//        return (numberId - minValue) / (maxValue - minValue);
        return numberId * 0.0000001f;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getTypeElement() {
        return this.typeElement;
    }

    public void setTypeElement(String typeElement) {
        this.typeElement = typeElement;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean isVariationPoint() {
        return this.getVariationPoint() != null;
    }

    public Variant getVariant() {
        return variant;
    }

    public void setVariant(Variant variant) {
        this.variant = variant;
    }

    @Override
    public String toString() {
        return getName();
    }

    public Set<Concern> getOwnConcerns() {
        if (concerns.isEmpty())
            return Collections.emptySet();
        return concerns;
    }

    public boolean containsConcern(Concern concern) {
        for (Concern ownConcern : getOwnConcerns()) {
            if (ownConcern.getName().equalsIgnoreCase(concern.getName()))
                return true;
        }
        return false;
    }

    public void addConcerns(List<String> concernsNames) throws ConcernNotFoundException {
        for (String name : concernsNames)
            addConcern(name);
    }

    public void addExternalConcern(Concern concern) {
        concerns.add(concern);
    }

    public void addConcern(String concernName) throws ConcernNotFoundException {
        Concern concern = ConcernHolder.INSTANCE.getOrCreateConcern(concernName);
        concerns.add(concern);
    }

    public void removeConcern(String concernName) {
        Concern concern = ConcernHolder.INSTANCE.getConcernByName(concernName);
        concerns.remove(concern);
    }

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public VariationPoint getVariationPoint() {
        return variationPoint;
    }

    public void setVariationPoint(VariationPoint variationPoint) {
        this.variationPoint = variationPoint;
    }

    public boolean doesBelongToGeneralization() {
        return this.belongsToGeneralization;
    }

    public void setBelongsToGeneralization(boolean belongsToGeneralization) {
        this.belongsToGeneralization = belongsToGeneralization;
    }

    public boolean isFreezeByDM() {
        return this.comments != null && this.comments.stream().anyMatch(c -> (c.getValue() != null && c.getValue().contains("freeze"))
                || (c.getName() != null && c.getName().contains("freeze")));
    }

    public boolean hasComments() {
        return !comments.isEmpty();
    }

    public boolean unsetFreezeFromDM() {
        this.comments = this.comments.stream().filter(c -> c.getValue() != null && !c.getValue().contains("freeze"))
                .collect(Collectors.toSet());
        return this.isFreezeByDM();
    }

    public boolean setFreezeFromDM() {
        if (!isFreezeByDM()) {
            this.comments.add(new Comment("freeze"));
        }
        return isFreezeByDM();
    }


    public boolean setFreezeFromDM(boolean bool) {
        return bool ? setFreezeFromDM() : unsetFreezeFromDM();
    }

    public boolean setFreezeFromDM(double bool) {
        return bool > 0 ? setFreezeFromDM() : unsetFreezeFromDM();
    }

    public boolean isFreezedByCluster() {
        return freezedByCluster;
    }

    public void setFreezedByCluster(boolean freezedByCluster) {
        this.freezedByCluster = freezedByCluster;
    }

    public void setFreezedByCluster() {
        this.freezedByCluster = true;
    }

    public boolean isTotalyFreezed() {
        return this.isFreezeByDM() || this.isFreezedByCluster();
    }

    public Set<Comment> getComments() {
        return comments;
    }

    public String getStringComments() {
        return comments.stream().map(c -> c.getValue() + "\n").collect(Collectors.joining());
    }

    public void setComments(String comments) {
        if (comments != null && !"null".equals(comments.trim()) && !comments.isEmpty()) {
            this.comments.add(new Comment(comments));
        }
    }

    public void setComments(Set<Comment> comments) {
        this.comments = comments;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((namespace == null) ? 0 : namespace.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        String objClass = obj.getClass().toString();
        if (this == obj)
            return true;
        if (!getClass().toString().equals(objClass))
            return false;
        Element other = (Element) obj;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (namespace == null) {
            return other.namespace == null;
        } else return namespace.equals(other.namespace);
    }

    @Override
    public boolean totalyEquals(MLElement other) {
        boolean doesEqual = this.getNumberId() == other.getNumberId();
        if (this instanceof Class && other instanceof Class) {
            doesEqual &= ((Class) this).getAllAttributes().equals(((Class) other).getAllAttributes());
            doesEqual &= ((Class) this).getAllMethods().equals(((Class) other).getAllMethods());
        } else if (this instanceof Interface && other instanceof Interface) {
            doesEqual &= ((Interface) this).getOperations().equals(((Interface) other).getOperations());
        } else if (this instanceof Package && other instanceof Package) {
            Set<Element> collect = ((Package) this).getElements();
            Set<Element> collect1 = ((Package) other).getElements();
            if (collect.size() != collect1.size()) return false;
            for (Element element : collect) {
                doesEqual &= element.totalyEquals(other);
            }
        }
        return doesEqual;
    }
}
package br.otimizes.oplatool.architecture.representation;

import br.otimizes.isearchai.learning.MLElement;
import br.otimizes.oplatool.architecture.exceptions.ConcernNotFoundException;
import com.rits.cloning.Cloner;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.eclipse.uml2.uml.Interface;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Element representation
 *
 * @author edipofederle<edipofederle @ gmail.com>
 */
public abstract class Element implements Serializable, br.otimizes.isearchai.learning.MLElement {

    private static final long serialVersionUID = 4736685073967472613L;

    protected String id;
    private String name;
    private VariationPoint variationPoint;
    private Variant variant;
    private final Set<Concern> concerns = new HashSet<>();
    private Set<Comment> comments = new HashSet<>();
    private String typeElement;
    private String namespace;
    private boolean belongsToGeneralization;
    private boolean freezedByCluster = false;
    private String posX = "0";
    private String posY = "0";
    private String globalPosX = "0";
    private String globalPosY = "0";
    private String height = "0";
    private String width = "0";
    private boolean mandatory = true;
    private boolean isStatic;
    private boolean isFinal;

    public Element(String name, Variant variant, String typeElement, String namespace, String id) {
        setId(id);
        setName(name);
        setVariant(variant);
        setTypeElement(typeElement);
        setNamespace(namespace);
    }

    public Element deepCopy() {
        try {
            return this.deepClone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }

    private Element deepClone() throws CloneNotSupportedException {
        Cloner cloner = new Cloner();
        Element pkg = cloner.deepClone(this);
        cloner = null;
        return pkg;
    }

    public String getPosX() {
        return posX;
    }

    public void setPosX(String posX) {
        this.posX = posX;
    }

    public String getPosY() {
        return posY;
    }

    public void setPosY(String posY) {
        this.posY = posY;
    }

    public String getGlobalPosX() {
        return globalPosX;
    }

    public void setGlobalPosX(String globalPosX) {
        this.globalPosX = globalPosX;
    }

    public String getGlobalPosY() {
        return globalPosY;
    }

    public void setGlobalPosY(String globalPosY) {
        this.globalPosY = globalPosY;
    }

    public String getHeight() {
        return height;
    }

    public void setHeight(String height) {
        this.height = height;
    }

    public String getWidth() {
        return width;
    }

    public void setWidth(String width) {
        this.width = width;
    }

    public boolean isMandatory() {
        return mandatory;
    }

    public void setMandatory(boolean mandatory) {
        this.mandatory = mandatory;
    }

    public boolean isStatic() {
        return isStatic;
    }

    public void setStatic(boolean aStatic) {
        isStatic = aStatic;
    }

    public boolean isFinal() {
        return isFinal;
    }

    public void setFinal(boolean aFinal) {
        isFinal = aFinal;
    }

    public abstract Collection<Concern> getAllConcerns();

    public String getId() {
        return id;
    }

    public float getNumberId() {
        int minValue = Integer.MIN_VALUE;
        int maxValue = Integer.MAX_VALUE;
        int numberId = (this.getNamespace() + ":" + this.getTypeElement() +
                ":" + this.getName()).hashCode();
//        return (numberId - minValue) / (maxValue - minValue);
        return numberId * 0.0000001f;
    }

    private void setId(String id) {
        this.id = id;
    }

    public String getTypeElement() {
        return this.typeElement;
    }

    public void setTypeElement(String typeElement) {
        this.typeElement = typeElement;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean isVariationPoint() {
        return this.getVariationPoint() != null;
    }

    public Variant getVariant() {
        return variant;
    }

    public void setVariant(Variant variant) {
        this.variant = variant;
    }

    @Override
    public String toString() {
        return getName();
    }

    public Set<Concern> getOwnConcerns() {
        if (concerns.isEmpty())
            return Collections.emptySet();
        return concerns;
    }

    public boolean containsConcern(Concern concern) {
        for (Concern ownConcern : getOwnConcerns()) {
            if (ownConcern.getName().equalsIgnoreCase(concern.getName()))
                return true;
        }
        return false;
    }

    public void addConcerns(List<String> concernsNames) throws ConcernNotFoundException {
        for (String name : concernsNames)
            addConcern(name);
    }

    public void addExternalConcern(Concern concern) {
        concerns.add(concern);
    }

    public void addConcern(String concernName) throws ConcernNotFoundException {
        Concern concern = ConcernHolder.INSTANCE.getOrCreateConcern(concernName);
        concerns.add(concern);
    }

    public void removeConcern(String concernName) {
        Concern concern = ConcernHolder.INSTANCE.getConcernByName(concernName);
        concerns.remove(concern);
    }

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public VariationPoint getVariationPoint() {
        return variationPoint;
    }

    public void setVariationPoint(VariationPoint variationPoint) {
        this.variationPoint = variationPoint;
    }

    public boolean doesBelongToGeneralization() {
        return this.belongsToGeneralization;
    }

    public void setBelongsToGeneralization(boolean belongsToGeneralization) {
        this.belongsToGeneralization = belongsToGeneralization;
    }

    public boolean isFreezeByDM() {
        return this.comments != null && this.comments.stream().anyMatch(c -> (c.getValue() != null && c.getValue().contains("freeze"))
                || (c.getName() != null && c.getName().contains("freeze")));
    }

    public boolean hasComments() {
        return !comments.isEmpty();
    }

    public boolean unsetFreezeFromDM() {
        this.comments = this.comments.stream().filter(c -> c.getValue() != null && !c.getValue().contains("freeze"))
                .collect(Collectors.toSet());
        return this.isFreezeByDM();
    }

    public boolean setFreezeFromDM() {
        if (!isFreezeByDM()) {
            this.comments.add(new Comment("freeze"));
        }
        return isFreezeByDM();
    }


    public boolean setFreezeFromDM(boolean bool) {
        return bool ? setFreezeFromDM() : unsetFreezeFromDM();
    }

    public boolean setFreezeFromDM(double bool) {
        return bool > 0 ? setFreezeFromDM() : unsetFreezeFromDM();
    }

    public boolean isFreezedByCluster() {
        return freezedByCluster;
    }

    public void setFreezedByCluster(boolean freezedByCluster) {
        this.freezedByCluster = freezedByCluster;
    }

    public void setFreezedByCluster() {
        this.freezedByCluster = true;
    }

    public boolean isTotalyFreezed() {
        return this.isFreezeByDM() || this.isFreezedByCluster();
    }

    public Set<Comment> getComments() {
        return comments;
    }

    public String getStringComments() {
        return comments.stream().map(c -> c.getValue() + "\n").collect(Collectors.joining());
    }

    public void setComments(String comments) {
        if (comments != null && !"null".equals(comments.trim()) && !comments.isEmpty()) {
            this.comments.add(new Comment(comments));
        }
    }

    public void setComments(Set<Comment> comments) {
        this.comments = comments;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((namespace == null) ? 0 : namespace.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        String objClass = obj.getClass().toString();
        if (this == obj)
            return true;
        if (!getClass().toString().equals(objClass))
            return false;
        Element other = (Element) obj;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        if (namespace == null) {
            return other.namespace == null;
        } else return namespace.equals(other.namespace);
    }

    @Override
    public boolean totalyEquals(MLElement other) {
        boolean doesEqual = this.getNumberId() == other.getNumberId();
        if (this instanceof Class && other instanceof Class) {
            doesEqual &= ((Class) this).getAllAttributes().equals(((Class) other).getAllAttributes());
            doesEqual &= ((Class) this).getAllMethods().equals(((Class) other).getAllMethods());
        } else if (this instanceof Interface && other instanceof Interface) {
            doesEqual &= ((Interface) this).getOperations().equals(((Interface) other).getOperations());
        } else if (this instanceof Package && other instanceof Package) {
            Set<Element> collect = ((Package) this).getElements();
            Set<Element> collect1 = ((Package) other).getElements();
            if (collect.size() != collect1.size()) return false;
            for (Element element : collect) {
                doesEqual &= element.totalyEquals(other);
            }
        }
        return doesEqual;
    }
}
package br.otimizes.oplatool.api.dto;

import br.otimizes.oplatool.api.gateway.OptimizationAlgorithms;
import br.otimizes.oplatool.architecture.builders.ArchitectureBuilders;
import br.otimizes.isearchai.learning.ClusteringAlgorithm;
import br.otimizes.isearchai.learning.Moment;
import br.otimizes.oplatool.core.jmetal4.core.SolutionSet;
import br.otimizes.oplatool.domain.config.ApplicationFileConfig;
import br.otimizes.oplatool.domain.config.ApplicationYamlConfig;
import br.otimizes.oplatool.patterns.strategies.ScopeSelection;
import com.fasterxml.jackson.annotation.JsonIgnore;
import interactive.InteractiveFunction;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class OptimizationDto {
    private OptimizationAlgorithms algorithm = OptimizationAlgorithms.NSGAII;
    private String description = "teste";
    private Boolean mutation = true;
    private Double mutationProbability = 0.9;
    private String inputArchitecture = "";
    private Integer numberRuns = 1;
    private Integer populationSize = 20;
    private Integer maxEvaluations = 300;
    private Boolean crossover = false;
    private Double crossoverProbability = 0.0;
    private Boolean interactive = false;
    private Integer maxInteractions = 0;
    private Integer firstInteraction = 0;
    private Integer intervalInteraction = 0;
    private Integer archiveSize = 0;
    private ClusteringAlgorithm clusteringAlgorithm = ClusteringAlgorithm.KMEANS;
    private Moment clusteringMoment = Moment.INTERACTIVE;
    private ArchitectureBuilders architectureBuilder = ArchitectureBuilders.SMARTY;
    @JsonIgnore
    private InteractiveFunction interactiveFunction;
    private List<String> mutationOperators = Arrays.asList("FEATURE_DRIVEN_OPERATOR", "MOVE_METHOD_MUTATION", "MOVE_ATTRIBUTE_MUTATION", "MOVE_OPERATION_MUTATION", "ADD_CLASS_MUTATION", "ADD_MANAGER_CLASS_MUTATION");
    private List<String> crossoverOperators = new ArrayList<>();
    private List<String> patterns = new ArrayList<>();
    private ScopeSelection scopeSelection = ScopeSelection.RANDOM;
    private List<String> objectiveFunctions = new ArrayList<>();
    public ApplicationYamlConfig config = ApplicationFileConfig.getInstance();


    public OptimizationDto() {
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Boolean getMutation() {
        return mutation;
    }

    public void setMutation(Boolean mutation) {
        this.mutation = mutation;
    }

    public Double getMutationProbability() {
        return mutationProbability;
    }

    public void setMutationProbability(Double mutationProbability) {
        this.mutationProbability = mutationProbability;
    }

    public String getInputArchitecture() {
        return inputArchitecture;
    }

    public void setInputArchitecture(String inputArchitecture) {
        this.inputArchitecture = inputArchitecture;
    }

    public Integer getNumberRuns() {
        return numberRuns;
    }

    public void setNumberRuns(Integer numberRuns) {
        this.numberRuns = numberRuns;
    }

    public Integer getPopulationSize() {
        return populationSize;
    }

    public void setPopulationSize(Integer populationSize) {
        this.populationSize = populationSize;
    }

    public Integer getMaxEvaluations() {
        return maxEvaluations;
    }

    public void setMaxEvaluations(Integer maxEvaluations) {
        this.maxEvaluations = maxEvaluations;
    }

    public Boolean getCrossover() {
        return crossover;
    }

    public void setCrossover(Boolean crossover) {
        this.crossover = crossover;
    }

    public Double getCrossoverProbability() {
        return crossoverProbability;
    }

    public void setCrossoverProbability(Double crossoverProbability) {
        this.crossoverProbability = crossoverProbability;
    }

    public Boolean getInteractive() {
        return interactive;
    }

    public void setInteractive(Boolean interactive) {
        this.interactive = interactive;
    }

    public Integer getMaxInteractions() {
        return maxInteractions;
    }

    public void setMaxInteractions(Integer maxInteractions) {
        this.maxInteractions = maxInteractions;
    }

    public Integer getFirstInteraction() {
        return firstInteraction;
    }

    public void setFirstInteraction(Integer firstInteraction) {
        this.firstInteraction = firstInteraction;
    }

    public Integer getIntervalInteraction() {
        return intervalInteraction;
    }

    public void setIntervalInteraction(Integer intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }

    public ClusteringAlgorithm getClusteringAlgorithm() {
        return clusteringAlgorithm;
    }

    public void setClusteringAlgorithm(ClusteringAlgorithm clusteringAlgorithm) {
        this.clusteringAlgorithm = clusteringAlgorithm;
    }

    public Moment getClusteringMoment() {
        return clusteringMoment;
    }

    public void setClusteringMoment(Moment clusteringMoment) {
        this.clusteringMoment = clusteringMoment;
    }

    public InteractiveFunction getInteractiveFunction() {
        return interactiveFunction;
    }

    public void setInteractiveFunction(InteractiveFunction<SolutionSet> interactiveFunction) {
        this.interactiveFunction = interactiveFunction;
    }

    public List<String> getMutationOperators() {
        return mutationOperators;
    }

    public void setMutationOperators(List<String> mutationOperators) {
        this.mutationOperators = mutationOperators;
    }

    public List<String> getPatterns() {
        return patterns;
    }

    public void setPatterns(List<String> patterns) {
        this.patterns = patterns;
    }

    public List<String> getObjectiveFunctions() {
        return objectiveFunctions;
    }

    public void setObjectiveFunctions(List<String> objectiveFunctions) {
        this.objectiveFunctions = objectiveFunctions;
    }

    public OptimizationAlgorithms getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(OptimizationAlgorithms algorithm) {
        this.algorithm = algorithm;
    }

    public ApplicationYamlConfig getConfig() {
        return config;
    }

    public void setConfig(ApplicationYamlConfig config) {
        this.config = config;
    }

    public Integer getArchiveSize() {
        return archiveSize;
    }

    public void setArchiveSize(Integer archiveSize) {
        this.archiveSize = archiveSize;
    }

    public ScopeSelection getScopeSelection() {
        return scopeSelection;
    }

    public void setScopeSelection(ScopeSelection scopeSelection) {
        this.scopeSelection = scopeSelection;
    }

    public ArchitectureBuilders getArchitectureBuilder() {
        return architectureBuilder;
    }

    public void setArchitectureBuilder(ArchitectureBuilders architectureBuilder) {
        this.architectureBuilder = architectureBuilder;
    }

    public List<String> getCrossoverOperators() {
        return crossoverOperators;
    }

    public void setCrossoverOperators(List<String> crossoverOperators) {
        this.crossoverOperators = crossoverOperators;
    }
}
package br.otimizes.oplatool.api.dto;

import br.otimizes.oplatool.api.gateway.OptimizationAlgorithms;
import br.otimizes.oplatool.architecture.builders.ArchitectureBuilders;
import br.otimizes.isearchai.learning.ClusteringAlgorithm;
import br.otimizes.isearchai.learning.Moment;
import br.otimizes.oplatool.core.jmetal4.core.SolutionSet;
import br.otimizes.oplatool.domain.config.ApplicationFileConfig;
import br.otimizes.oplatool.domain.config.ApplicationYamlConfig;
import br.otimizes.oplatool.patterns.strategies.ScopeSelection;
import com.fasterxml.jackson.annotation.JsonIgnore;
import interactive.InteractiveFunction;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class OptimizationDto {
    private OptimizationAlgorithms algorithm = OptimizationAlgorithms.NSGAII;
    private String description = "teste";
    private Boolean mutation = true;
    private Double mutationProbability = 0.9;
    private String inputArchitecture = "";
    private Integer numberRuns = 1;
    private Integer populationSize = 20;
    private Integer maxEvaluations = 300;
    private Boolean crossover = false;
    private Double crossoverProbability = 0.0;
    private Boolean interactive = false;
    private Integer maxInteractions = 0;
    private Integer firstInteraction = 0;
    private Integer intervalInteraction = 0;
    private Integer archiveSize = 0;
    private ClusteringAlgorithm clusteringAlgorithm = ClusteringAlgorithm.KMEANS;
    private Moment clusteringMoment = Moment.INTERACTIVE;
    private ArchitectureBuilders architectureBuilder = ArchitectureBuilders.SMARTY;
    @JsonIgnore
    private InteractiveFunction interactiveFunction;
    private List<String> mutationOperators = Arrays.asList("FEATURE_DRIVEN_OPERATOR", "MOVE_METHOD_MUTATION", "MOVE_ATTRIBUTE_MUTATION", "MOVE_OPERATION_MUTATION", "ADD_CLASS_MUTATION", "ADD_MANAGER_CLASS_MUTATION");
    private List<String> crossoverOperators = new ArrayList<>();
    private List<String> patterns = new ArrayList<>();
    private ScopeSelection scopeSelection = ScopeSelection.RANDOM;
    private List<String> objectiveFunctions = new ArrayList<>();
    public ApplicationYamlConfig config = ApplicationFileConfig.getInstance();


    public OptimizationDto() {
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Boolean getMutation() {
        return mutation;
    }

    public void setMutation(Boolean mutation) {
        this.mutation = mutation;
    }

    public Double getMutationProbability() {
        return mutationProbability;
    }

    public void setMutationProbability(Double mutationProbability) {
        this.mutationProbability = mutationProbability;
    }

    public String getInputArchitecture() {
        return inputArchitecture;
    }

    public void setInputArchitecture(String inputArchitecture) {
        this.inputArchitecture = inputArchitecture;
    }

    public Integer getNumberRuns() {
        return numberRuns;
    }

    public void setNumberRuns(Integer numberRuns) {
        this.numberRuns = numberRuns;
    }

    public Integer getPopulationSize() {
        return populationSize;
    }

    public void setPopulationSize(Integer populationSize) {
        this.populationSize = populationSize;
    }

    public Integer getMaxEvaluations() {
        return maxEvaluations;
    }

    public void setMaxEvaluations(Integer maxEvaluations) {
        this.maxEvaluations = maxEvaluations;
    }

    public Boolean getCrossover() {
        return crossover;
    }

    public void setCrossover(Boolean crossover) {
        this.crossover = crossover;
    }

    public Double getCrossoverProbability() {
        return crossoverProbability;
    }

    public void setCrossoverProbability(Double crossoverProbability) {
        this.crossoverProbability = crossoverProbability;
    }

    public Boolean getInteractive() {
        return interactive;
    }

    public void setInteractive(Boolean interactive) {
        this.interactive = interactive;
    }

    public Integer getMaxInteractions() {
        return maxInteractions;
    }

    public void setMaxInteractions(Integer maxInteractions) {
        this.maxInteractions = maxInteractions;
    }

    public Integer getFirstInteraction() {
        return firstInteraction;
    }

    public void setFirstInteraction(Integer firstInteraction) {
        this.firstInteraction = firstInteraction;
    }

    public Integer getIntervalInteraction() {
        return intervalInteraction;
    }

    public void setIntervalInteraction(Integer intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }

    public ClusteringAlgorithm getClusteringAlgorithm() {
        return clusteringAlgorithm;
    }

    public void setClusteringAlgorithm(ClusteringAlgorithm clusteringAlgorithm) {
        this.clusteringAlgorithm = clusteringAlgorithm;
    }

    public Moment getClusteringMoment() {
        return clusteringMoment;
    }

    public void setClusteringMoment(Moment clusteringMoment) {
        this.clusteringMoment = clusteringMoment;
    }

    public InteractiveFunction getInteractiveFunction() {
        return interactiveFunction;
    }

    public void setInteractiveFunction(InteractiveFunction<SolutionSet> interactiveFunction) {
        this.interactiveFunction = interactiveFunction;
    }

    public List<String> getMutationOperators() {
        return mutationOperators;
    }

    public void setMutationOperators(List<String> mutationOperators) {
        this.mutationOperators = mutationOperators;
    }

    public List<String> getPatterns() {
        return patterns;
    }

    public void setPatterns(List<String> patterns) {
        this.patterns = patterns;
    }

    public List<String> getObjectiveFunctions() {
        return objectiveFunctions;
    }

    public void setObjectiveFunctions(List<String> objectiveFunctions) {
        this.objectiveFunctions = objectiveFunctions;
    }

    public OptimizationAlgorithms getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(OptimizationAlgorithms algorithm) {
        this.algorithm = algorithm;
    }

    public ApplicationYamlConfig getConfig() {
        return config;
    }

    public void setConfig(ApplicationYamlConfig config) {
        this.config = config;
    }

    public Integer getArchiveSize() {
        return archiveSize;
    }

    public void setArchiveSize(Integer archiveSize) {
        this.archiveSize = archiveSize;
    }

    public ScopeSelection getScopeSelection() {
        return scopeSelection;
    }

    public void setScopeSelection(ScopeSelection scopeSelection) {
        this.scopeSelection = scopeSelection;
    }

    public ArchitectureBuilders getArchitectureBuilder() {
        return architectureBuilder;
    }

    public void setArchitectureBuilder(ArchitectureBuilders architectureBuilder) {
        this.architectureBuilder = architectureBuilder;
    }

    public List<String> getCrossoverOperators() {
        return crossoverOperators;
    }

    public void setCrossoverOperators(List<String> crossoverOperators) {
        this.crossoverOperators = crossoverOperators;
    }
}
package br.otimizes.oplatool.api.resource;

import br.otimizes.oplatool.api.dto.OptimizationDto;
import br.otimizes.oplatool.api.utils.Interaction;
import br.otimizes.oplatool.api.utils.Interactions;
import br.otimizes.oplatool.domain.entity.EmailDto;
import br.otimizes.oplatool.architecture.io.OPLALogs;
import br.otimizes.oplatool.architecture.io.OptimizationInfo;
import br.otimizes.oplatool.architecture.io.OptimizationInfoStatus;
import br.otimizes.oplatool.core.jmetal4.core.SolutionSet;
import br.otimizes.isearchai.learning.Clustering;
import br.otimizes.oplatool.domain.OPLAThreadScope;
import br.otimizes.oplatool.domain.entity.User;
import br.otimizes.oplatool.persistence.service.EmailService;
import br.otimizes.oplatool.persistence.service.UserService;
import org.springframework.stereotype.Service;

@Service
public class InteractiveEmail {

    private final EmailService emailService;
    private final UserService userService;

    public InteractiveEmail(EmailService emailService, UserService userService) {
        this.emailService = emailService;
        this.userService = userService;
    }

    public SolutionSet run(SolutionSet solutionSet, OptimizationDto optimizationDto) {
        for (int i = 0; i < solutionSet.getSolutionSet().size(); i++) {
            solutionSet.get(i).setId(i);
        }
        // when "debugging" gives an error HERE
        OPLALogs.add(new OptimizationInfo(OPLAThreadScope.mainThreadId.get(), "Your optimization is waiting for evaluation.", OptimizationInfoStatus.INTERACT));
        try {
            User userByEmail = userService.findUserByToken(OPLAThreadScope.token.get());
            emailService.send(new EmailDto(userByEmail.getLogin(), "Your optimization is waiting for evaluation.", "Your optimization is waiting for evaluation."));
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            if (solutionSet.size() > 0) {
                Clustering clustering = new Clustering(solutionSet, optimizationDto.getClusteringAlgorithm());
                clustering.setNumClusters(solutionSet.getSolutionSet().get(0).numberOfObjectives() + 1);
                clustering.run();
                Interactions.set(OPLAThreadScope.hash.get(), new Interaction(solutionSet));
                System.out.println("Waiting interaction: " + !Interactions.get(OPLAThreadScope.hash.get()).updated);
                while (!Interactions.get(OPLAThreadScope.hash.get()).updated) {
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return Interactions.get(OPLAThreadScope.hash.get()).solutionSet;
    }


}

//  Solution.java
//
//  Author:
//       Antonio J. Nebro <antonio@lcc.uma.es>
//       Juan J. Durillo <durillo@lcc.uma.es>
//
//  Description:
//
//  Copyright (c) 2011 Antonio J. Nebro, Juan J. Durillo
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

package br.otimizes.oplatool.core.jmetal4.core;

import br.otimizes.isearchai.learning.MLSolution;
import br.otimizes.oplatool.architecture.representation.Architecture;
import br.otimizes.oplatool.architecture.representation.Element;
import br.otimizes.oplatool.common.Variable;
import br.otimizes.oplatool.core.jmetal4.encodings.variable.Binary;
import com.fasterxml.jackson.annotation.JsonIgnore;

import java.io.Serializable;
import java.util.Collections;
import java.util.List;

/**
 * Class representing a solution for a problem.
 */
public class Solution implements Serializable, MLSolution<Element> {
    /**
     *
     */
    private static final long serialVersionUID = 2508217794094374887L;


    String solutionName;

    /**
     * Stores the problem
     */
    Problem problem_;

    /**
     * Stores the type of the variable
     */
    private SolutionType type_;

    /**
     * Stores the decision variables of the solution.
     */
    private Variable[] variable_;

    /**
     * Stores the objectives values of the solution.
     */
    private double[] objective_;
    // para guardar os valores de cada metrica quando executar o GA
    private double[] objective_temp_;

    /**
     * Stores a list of maximum values for each objective.
     */
    public double [] objectiveMax;

    /**
     * Stores the number of objective values of the solution
     */
    private int numberOfObjectives_;

    /**
     * Stores the so called fitness value. Used in some metaheuristics
     */
    private double fitness_;

    /**
     * Used in algorithm AbYSS, this field is intended to be used to know when a
     * <code>Solution</code> is marked.
     */
    private boolean marked_;

    /**
     * Stores the so called rank of the solution. Used in NSGA-II
     */
    private int rank_;

    /**
     * Stores the overall constraint violation of the solution.
     */
    private double overallConstraintViolation_;

    /**
     * Stores the number of constraints violated by the solution.
     */
    private int numberOfViolatedConstraints_;

    /**
     * This field is intended to be used to know the location of a solution into
     * a <code>SolutionSet</code>. Used in MOCell
     */
    private int location_;

    /**
     * Stores the distance to his k-nearest neighbor into a
     * <code>SolutionSet</code>. Used in SPEA2.
     */
    private double kDistance_;

    /**
     * Stores the crowding distance of the the solution in a
     * <code>SolutionSet</code>. Used in NSGA-II.
     */
    private double crowdingDistance_;

    /**
     * Stores the distance between this solution and a <code>SolutionSet</code>.
     * Used in AbySS.
     */
    private double distanceToSolutionSet_;

    /**
     * Stores the cluster realized by AbstractClustering Filter
     */
    private Double clusterId_;

    private int userEvaluation;

    private String executionId_;

    private String experimentId_;

    private int id;

    private int idOrigem;

    private Boolean clusterNoise_;

    public Boolean evaluatedByUser;
    private double[] normalizedObjective_;

    public Boolean evaluatedByUser3;

    public Boolean ratedSolution;

    /**
     * Constructor.
     */
    private int clusterIDForMetaHeuristics;
    private double vDistance_;

    public Solution() {
        problem_ = null;
        marked_ = false;
        overallConstraintViolation_ = 0.0;
        numberOfViolatedConstraints_ = 0;
        type_ = null;
        variable_ = null;
        objective_ = null;

        objectiveMax = null;
    } // Solution

    /**
     * Constructor
     *
     * @param numberOfObjectives Number of objectives of the solution
     *                           <p>
     *                           This constructor is used mainly to read objective values from
     *                           a file to variables of a SolutionSet to apply quality
     *                           indicators
     */
    public Solution(int numberOfObjectives) {
        numberOfObjectives_ = numberOfObjectives;
        objective_ = new double[numberOfObjectives];

        normalizedObjective_ = new double[numberOfObjectives_];

        objectiveMax = new double[numberOfObjectives];
    }

    public Solution(Problem problem) throws ClassNotFoundException {
        problem_ = problem;
        type_ = problem.getSolutionType();
        numberOfObjectives_ = problem.getNumberOfObjectives();
        objective_ = new double[numberOfObjectives_];
        fitness_ = 0.0;
        kDistance_ = 0.0;
        crowdingDistance_ = 0.0;
        distanceToSolutionSet_ = Double.POSITIVE_INFINITY;
        normalizedObjective_ = new double[numberOfObjectives_];
        variable_ = type_.createVariables();

        objectiveMax = new double[numberOfObjectives_];
    } // Solution

    public Solution(Problem problem, Variable[] variables) {
        problem_ = problem;
        type_ = problem.getSolutionType();
        numberOfObjectives_ = problem.getNumberOfObjectives();
        objective_ = new double[numberOfObjectives_];
        fitness_ = 0.0;
        kDistance_ = 0.0;
        crowdingDistance_ = 0.0;
        distanceToSolutionSet_ = Double.POSITIVE_INFINITY;
        normalizedObjective_ = new double[numberOfObjectives_];
        variable_ = variables;

        objectiveMax = new double[numberOfObjectives_];

    } // Constructor

    /**
     * Copy constructor.
     *
     * @param solution Solution to copy.
     */
    public Solution(Solution solution) {
        problem_ = solution.problem_;
        type_ = solution.type_;
        numberOfObjectives_ = solution.numberOfObjectives();
        objective_ = new double[numberOfObjectives_];
        normalizedObjective_ = new double[numberOfObjectives_];
        for (int i = 0; i < objective_.length; i++)
        {
            objective_[i] = solution.getObjective(i);
            normalizedObjective_[i] = solution.getNormalizedObjective(i);
        } // for
        // <-

        objectiveMax = new double[numberOfObjectives_];

        for (int i = 0; i < objective_.length; i++) {
            objective_[i] = solution.getObjective(i);
        }
        if (solution.objective_temp_ != null) {
            objective_temp_ = new double[solution.objective_temp_.length];
            for (int i = 0; i < objective_temp_.length; i++) {
                objective_temp_[i] = solution.getObjectiveTemp(i);
            }
        }
        variable_ = type_.copyVariables(solution.variable_);
        overallConstraintViolation_ = solution.getOverallConstraintViolation();
        numberOfViolatedConstraints_ = solution.getNumberOfViolatedConstraint();
        distanceToSolutionSet_ = solution.getDistanceToSolutionSet();
        crowdingDistance_ = solution.getCrowdingDistance();
        kDistance_ = solution.getKDistance();
        fitness_ = solution.getFitness();
        marked_ = solution.isMarked();
        rank_ = solution.getRank();
        location_ = solution.getLocation();
    } // Solution

    static public Solution getNewSolution(Problem problem) throws ClassNotFoundException {
        return new Solution(problem);
    }

    /**
     * Gets the distance from the solution to a <code>SolutionSet</code>. <b>
     * REQUIRE </b>: this method has to be invoked after calling
     * <code>setDistanceToPopulation</code>.
     *
     * @return the distance to a specific solutionSet.
     */
    public double getDistanceToSolutionSet() {
        return distanceToSolutionSet_;
    } // getDistanceToSolutionSet

    /**
     * Sets the distance between this solution and a <code>SolutionSet</code>.
     * The value is stored in <code>distanceToSolutionSet_</code>.
     *
     * @param distance The distance to a solutionSet.
     */
    public void setDistanceToSolutionSet(double distance) {
        distanceToSolutionSet_ = distance;
    } // SetDistanceToSolutionSet

    /**
     * Gets the distance from the solution to his k-nearest nighbor in a
     * <code>SolutionSet</code>. Returns the value stored in
     * <code>kDistance_</code>. <b> REQUIRE </b>: this method has to be invoked
     * after calling <code>setKDistance</code>.
     *
     * @return the distance to k-nearest neighbor.
     */
    public double getKDistance() {
        return kDistance_;
    } // getKDistance

    /**
     * Sets the distance between the solution and its k-nearest neighbor in a
     * <code>SolutionSet</code>. The value is stored in <code>kDistance_</code>.
     *
     * @param distance The distance to the k-nearest neighbor.
     */
    public void setKDistance(double distance) {
        kDistance_ = distance;
    } // setKDistance

    /**
     * Gets the crowding distance of the solution into a
     * <code>SolutionSet</code>. Returns the value stored in
     * <code>crowdingDistance_</code>. <b> REQUIRE </b>: this method has to be
     * invoked after calling <code>setCrowdingDistance</code>.
     *
     * @return the distance crowding distance of the solution.
     */
    public double getCrowdingDistance() {
        return crowdingDistance_;
    } // getCrowdingDistance

    /**
     * Sets the crowding distance of a solution in a <code>SolutionSet</code>.
     * The value is stored in <code>crowdingDistance_</code>.
     *
     * @param distance The crowding distance of the solution.
     */
    public void setCrowdingDistance(double distance) {
        crowdingDistance_ = distance;
    } // setCrowdingDistance

    /**
     * Gets the fitness of the solution. Returns the value of stored in the
     * variable <code>fitness_</code>. <b> REQUIRE </b>: This method has to be
     * invoked after calling <code>setFitness()</code>.
     *
     * @return the fitness.
     */
    public double getFitness() {
        return fitness_;
    } // getFitness

    /**
     * Sets the fitness of a solution. The value is stored in
     * <code>fitness_</code>.
     *
     * @param fitness The fitness of the solution.
     */
    public void setFitness(double fitness) {
        fitness_ = fitness;
    } // setFitness

    /**
     * Sets the value of the i-th objective.
     *
     * @param i     The number identifying the objective.
     * @param value The value to be stored.
     */
    public void setObjective(int i, double value) {
        objective_[i] = value;
    } // setObjective

    /**
     * Returns the value of the i-th objective.
     *
     * @param i The value of the objective.
     */
    public double getObjective(int i) {
        return objective_[i];
    } // getObjective

    public double[] getObjectives() {
        return objective_;
    }

    @JsonIgnore
    public Problem getProblem() {
        return problem_;
    }

    public void setProblem(Problem problem_) {
        this.problem_ = problem_;
    }

    public void createObjectiveTemp(int numberOfObjectives) {
        objective_temp_ = new double[numberOfObjectives];
    }

   /* public void createObjectiveMax(int numberOfObjectives) {
        objectiveMax = new double[numberOfObjectives];
    }

    */

    public void createObjective(int numberOfObjectives) {
        objective_ = new double[numberOfObjectives];
    }

    public void setObjectiveTemp(int i, double value) {
        objective_temp_[i] = value;
    } // setObjective

    public double getObjectiveTemp(int i) {
        return objective_temp_[i];
    } // getObjective

    /**
     * Returns the number of objectives.
     *
     * @return The number of objectives.
     */
    public int numberOfObjectives() {
        if (objective_ == null)
            return 0;
        else
            return numberOfObjectives_;
    } // numberOfObjectives

    public void setNumberOfObjectives(int numberOfObjectives_) {
        this.numberOfObjectives_ = numberOfObjectives_;
    }

    /**
     * Returns the number of decision variables of the solution.
     *
     * @return The number of decision variables.
     */
    public int numberOfVariables() {
        return problem_.getNumberOfVariables();
    } // numberOfVariables

    /**
     * Returns a string representing the solution.
     *
     * @return The string.
     */
    public String toString() {
        String aux = "";
        for (int i = 0; i < this.numberOfObjectives_; i++)
            aux = aux + this.getObjective(i) + " ";

        if (objective_temp_ != null) {
            aux = aux + " -> ";
            for (int i = 0; i < objective_temp_.length; i++) {
                aux = aux + this.getObjectiveTemp(i) + " ";
            }
        }

        return aux;
    } // toString

    public String toStringObjectivesTemp() {
        String aux = "";

        if (objective_temp_ != null) {
            for (int i = 0; i < objective_temp_.length; i++) {
                aux = aux + this.getObjectiveTemp(i) + " ";
            }
        }

        return aux;
    }

    public String toStringObjectives() {
        String aux = "";

        if (objective_ != null) {
            for (int i = 0; i < objective_.length; i++) {
                aux = aux + this.getObjective(i) + " ";
            }
        }

        return aux;
    }

    /**
     * Returns the decision variables of the solution.
     *
     * @return the <code>DecisionVariables</code> object representing the
     * decision variables of the solution.
     */
    @JsonIgnore
    public Variable[] getDecisionVariables() {
        return variable_;
    } // getDecisionVariables

    /**
     * Sets the decision variables for the solution.
     *
     * @param decisionVariables The <code>DecisionVariables</code> object representing the
     *                          decision variables of the solution.
     */
    public void setDecisionVariables(Variable[] decisionVariables) {
        variable_ = decisionVariables;
    } // setDecisionVariables

    /**
     * Indicates if the solution is marked.
     *
     * @return true if the method <code>marked</code> has been called and, after
     * that, the method <code>unmarked</code> hasn't been called. False
     * in other case.
     */
    public boolean isMarked() {
        return this.marked_;
    } // isMarked

    /**
     * Establishes the solution as marked.
     */
    public void marked() {
        this.marked_ = true;
    } // marked

    /**
     * Established the solution as unmarked.
     */
    public void unMarked() {
        this.marked_ = false;
    } // unMarked

    /**
     * Gets the rank of the solution. <b> REQUIRE </b>: This method has to be
     * invoked after calling <code>setRank()</code>.
     *
     * @return the rank of the solution.
     */
    public int getRank() {
        return this.rank_;
    } // getRank

    /**
     * Sets the rank of a solution.
     *
     * @param value The rank of the solution.
     */
    public void setRank(int value) {
        this.rank_ = value;
    } // setRank

    /**
     * Gets the overall constraint violated by the solution. <b> REQUIRE </b>:
     * This method has to be invoked after calling
     * <code>overallConstraintViolation</code>.
     *
     * @return the overall constraint violation by the solution.
     */
    public double getOverallConstraintViolation() {
        return this.overallConstraintViolation_;
    } // getOverallConstraintViolation

    /**
     * Sets the overall constraints violated by the solution.
     *
     * @param value The overall constraints violated by the solution.
     */
    public void setOverallConstraintViolation(double value) {
        this.overallConstraintViolation_ = value;
    } // setOverallConstraintViolation

    /**
     * Gets the number of constraint violated by the solution. <b> REQUIRE </b>:
     * This method has to be invoked after calling
     * <code>setNumberOfViolatedConstraint</code>.
     *
     * @return the number of constraints violated by the solution.
     */
    public int getNumberOfViolatedConstraint() {
        return this.numberOfViolatedConstraints_;
    } // getNumberOfViolatedConstraint

    /**
     * Sets the number of constraints violated by the solution.
     *
     * @param value The number of constraints violated by the solution.
     */
    public void setNumberOfViolatedConstraint(int value) {
        this.numberOfViolatedConstraints_ = value;
    } // setNumberOfViolatedConstraint

    /**
     * Gets the location of this solution in a <code>SolutionSet</code>. <b>
     * REQUIRE </b>: This method has to be invoked after calling
     * <code>setLocation</code>.
     *
     * @return the location of the solution into a solutionSet
     */
    public int getLocation() {
        return this.location_;
    } // getLocation

    /**
     * Sets the location of the solution into a solutionSet.
     *
     * @param location The location of the solution.
     */
    public void setLocation(int location) {
        this.location_ = location;
    } // setLocation

    /**
     * Sets the type of the variable.
     *
     * @param type
     *            The type of the variable.
     */
    // public void setType(String type) {
    // type_ = Class.forName("") ;
    // } // setType

    /**
     * Gets the type of the variable
     *
     * @return the type of the variable
     */
    @JsonIgnore
    public SolutionType getType() {
        return type_;
    } // getType

    /**
     * Sets the type of the variable.
     *
     * @param type The type of the variable.
     */
    public void setType(SolutionType type) {
        type_ = type;
    } // setType

    /**
     * Returns the aggregative value of the solution
     *
     * @return The aggregative value.
     */
    public double getAggregativeValue() {
        double value = 0.0;
        for (int i = 0; i < numberOfObjectives(); i++) {
            value += getObjective(i);
        }
        return value;
    } // getAggregativeValue


    public String getSolutionName() {
        return solutionName;
    }

    public void setSolutionName(String solutionName) {
        this.solutionName = solutionName;
    }

    /**
     * Returns the number of bits of the chromosome in case of using a binary
     * representation
     *
     * @return The number of bits if the case of binary variables, 0 otherwise
     */
    @JsonIgnore
    public int getNumberOfBits() {
        int bits = 0;

        for (int i = 0; i < variable_.length; i++)
            try {
                if ((variable_[i].getVariableType() == Class.forName("br.otimizes.oplatool.core.jmetal4.encodings.variable.Binary"))
                        || (variable_[i].getVariableType() == Class.forName("br.otimizes.oplatool.core.jmetal4.encodings.variable.BinaryReal")))
                    bits += ((Binary) (variable_[i])).getNumberOfBits();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        return bits;
    } // getNumberOfBits

    public Double getClusterId() {
        return clusterId_;
    }

    public void setClusterId(Double clusterId_) {
        this.clusterId_ = clusterId_;
    }

    public int getEvaluation() {
        return userEvaluation;
    }

    @Override
    @JsonIgnore
    public List<Element> getFreezedElements() {
        return getAlternativeArchitecture().getFreezedElements();
    }

    @Override
    @JsonIgnore
    public List<Element> getAllElements() {
        return getAlternativeArchitecture().getElementsWithPackages();
    }

    @Override
    public List<Element> findElementByNumberId(Double id) {
        return Collections.emptyList();
    }

    public void setEvaluation(int userEvaluation) {
        this.userEvaluation = userEvaluation;
    }

    @Override
    @JsonIgnore
    public List<Element> getElements() {
        return getAlternativeArchitecture().getElementsWithPackages();
    }

    public String getExecutionId() {
        return executionId_;
    }

    public void setExecutionId(String executionId_) {
        this.executionId_ = executionId_;
    }

    public Boolean getClusterNoise() {
        return clusterNoise_ != null && clusterNoise_;
    }

    public void setClusterNoise(Boolean clusterNoise_) {
        this.clusterNoise_ = clusterNoise_;
    }

    @JsonIgnore
    public boolean containsArchitecturalEvaluation() {
        for (Element element : getAlternativeArchitecture().getElementsWithPackages()) {
            if (element.isFreezeByDM()) {
                return true;
            }
        }
        return false;
    }

    public Architecture getAlternativeArchitecture() {
        return (Architecture) getDecisionVariables()[0];
    }

    public Boolean getEvaluatedByUser() {
        return evaluatedByUser != null && evaluatedByUser;
    }

    public void setEvaluatedByUser(Boolean evaluatedByUser) {
        this.evaluatedByUser = evaluatedByUser;
    }

    public Boolean getEvaluatedByUser3() {
        return evaluatedByUser3 != null && evaluatedByUser3;
    }

    public void setEvaluatedByUser3(Boolean evaluatedByUser) {
        this.evaluatedByUser3 = evaluatedByUser;
    }

    public Boolean getRatedSolution() {
        return ratedSolution != null && ratedSolution;
    }

    public void setRatedSolution(Boolean ratedSolution) {
        this.ratedSolution = ratedSolution;
    }

    public String getExperimentId() {
        return experimentId_;
    }

    public void setExperimentId(String experimentId_) {
        this.experimentId_ = experimentId_;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setNormalizedObjective(int i, double value)
    {
        normalizedObjective_[i] = value;
    }

    public double getNormalizedObjective(int i)
    {
        return normalizedObjective_[i];
    }

    public void setClusterIDForMetaHeuristics(int id)
    {
        this.clusterIDForMetaHeuristics = id;
    }

    public int getClusterIDForMetaHeuristics()
    {
        return this.clusterIDForMetaHeuristics;
    }

    public void setVDistance(double val)
    {
        this.vDistance_ = val;
    }

    public double getVDistance()
    {
        return this.vDistance_;
    }


    public int getIdOrigem() {
        return idOrigem;
    }

    public void setIdOrigem(int idOrigem) {
        this.idOrigem = idOrigem;
    }

    /**
     * Weigh the objective according to the assessments
     *
     * @param objective     The objective value that will be weighted.
     * @param evaluation    The value of evaluation (3 or 4).
     */
    public double getObjectiveWithWeight (double objective, int evaluation) {
        double weightsEvaluate4 = 0.14;
        double weightsEvaluate3 = 0.06;

        double value = objective;

        if (evaluation == 4) {
            value = (objective - objective * weightsEvaluate4);
        }

        if (evaluation == 3) {
            value = (objective - objective * weightsEvaluate3);
        }
        return value;
    }

    /**
     * Sets the value of the i-th objective.
     *
     * @param i     The number identifying the objective.
     * @param value The value to be stored.
     */
    public void setObjectiveMax(int i, double value) {
        objectiveMax[i] = value;
    } // setObjective

    /**
     * Returns the maximum value of the i-th objective.
     *
     * @param i The value of the objective.
     */
    public double getObjectiveMax(int i) {
        return objectiveMax[i];
    } // getObjective

    /**
     * run through all objectives to check the biggest
     *
     * @return returns a solution with the highest objective values
     */

    public void checkMajorObjective(SolutionSet solutionSet) {
        for (int i = 0; i < solutionSet.get(0).numberOfObjectives(); i++) {
            double maxObjective = 0;
            for (int j = 0; j < solutionSet.size(); j++ ) {
                if (maxObjective < solutionSet.get(j).getObjective(i)) {
                    maxObjective =  solutionSet.get(j).getObjective(i);
                }
            }
            setObjectiveMax(i,maxObjective);
        }
    }

} // Solution




//  SolutionSet.Java
//
//  Author:
//       Antonio J. Nebro <antonio@lcc.uma.es>
//       Juan J. Durillo <durillo@lcc.uma.es>
//
//  Copyright (c) 2011 Antonio J. Nebro, Juan J. Durillo
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

package br.otimizes.oplatool.core.jmetal4.core;

import br.otimizes.isearchai.learning.*;
import br.otimizes.oplatool.architecture.representation.*;
import br.otimizes.oplatool.architecture.representation.Class;
import br.otimizes.oplatool.architecture.representation.Package;
import br.otimizes.oplatool.architecture.smarty.util.SaveStringToFile;
import br.otimizes.oplatool.common.Configuration;
import br.otimizes.oplatool.common.exceptions.JMException;
import br.otimizes.oplatool.core.jmetal4.problems.OPLA;
import br.otimizes.oplatool.core.jmetal4.qualityIndicator.QualityIndicator;
import br.otimizes.oplatool.domain.config.ApplicationFileConfigThreadScope;
import br.otimizes.oplatool.domain.config.FileConstants;
import br.otimizes.oplatool.domain.entity.Info;
import br.ufpr.dinf.gres.loglog.Level;
import br.ufpr.dinf.gres.loglog.LogLog;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.log4j.Logger;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Class representing a SolutionSet (a set of solutions)
 */
public class SolutionSet extends MLSolutionSet<Solution, Element> implements Serializable, Iterable<Solution> {

    private static final Logger LOGGER = Logger.getLogger(SolutionSet.class);

    /**
     *
     */
    private static final long serialVersionUID = 2100295237257916377L;

    /**
     * Maximum size of the solution set
     */
    private int capacity_ = 0;

    /**
     * Stores a Solution with the maximum values for each objective.
     */
    private double [] objectiveMax;

    /**
     * Constructor. Creates an unbounded solution set.
     */
    public SolutionSet() {
        solutions = new ArrayList<>();
    } // SolutionSet

    /**
     * Creates a empty solutionSet with a maximum capacity.
     *
     * @param maximumSize Maximum size.
     */
    public SolutionSet(int maximumSize) {
        solutions = new ArrayList<>();
        capacity_ = maximumSize;
    } // SolutionSet

    public SolutionSet(SolutionSet resultFront) {
        this.capacity_ = resultFront.capacity_;
        this.solutions = resultFront.solutions;
    }

    /**
     * Inserts a new solution into the SolutionSet.
     *
     * @param solution The <code>Solution</code> to store
     * @return True If the <code>Solution</code> has been inserted, false
     * otherwise.
     */
    public boolean add(Solution solution) {
        if (solutions.size() == capacity_) {
            Configuration.logger_.severe("The population is full");
            Configuration.logger_.severe("Capacity is : " + capacity_);
            Configuration.logger_.severe("\t Size is: " + this.size());
            throw new RuntimeException();
//            return false;
        } // if

        solutions.add(solution);

        return true;
    } // add

    public int getCapacity() {
        return capacity_;
    }

    public void setCapacity(int capacity_) {
        this.capacity_ = capacity_;
    }

    /**
     * Returns the ith solution in the set.
     *
     * @param i Position of the solution to obtain.
     * @return The <code>Solution</code> at the position i.
     * @throws IndexOutOfBoundsException
     */
    public Solution get(int i) {
        if (i >= solutions.size()) {
            LOGGER.warn("Index out of Bound " + i);
            throw new IndexOutOfBoundsException("Index out of Bound " + i);
        }
        return solutions.get(i);
    } // get

    /**
     * Returns the maximum capacity of the solution set
     *
     * @return The maximum capacity of the solution set
     */
    public int getMaxSize() {
        return capacity_;
    } // getMaxSize

    /**
     * Sorts a SolutionSet using a <code>Comparator</code>.
     *
     * @param comparator <code>Comparator</code> used to sort.
     */
    public void sort(Comparator<Solution> comparator) {
        if (comparator == null) {
            Configuration.logger_.severe("No criterium for compare exist");
            return;
        } // if
        Collections.sort(solutions, comparator);
    } // sort

    /**
     * Returns the index of the best Solution using a <code>Comparator</code>.
     * If there are more than one occurrences, only the index of the first one
     * is returned
     *
     * @param comparator <code>Comparator</code> used to compare solutions.
     * @return The index of the best Solution attending to the comparator or
     * <code>-1<code> if the SolutionSet is empty
     */
    public int indexBest(Comparator<Solution> comparator) {

        if ((solutions == null) || (this.solutions.isEmpty())) {
            return -1;
        }

        int index = 0;
        Solution bestKnown = solutions.get(0), candidateSolution;
        int flag;
        for (int i = 1; i < solutions.size(); i++) {
            candidateSolution = solutions.get(i);
            flag = comparator.compare(bestKnown, candidateSolution);
            if (flag == -1) {
                index = i;
                bestKnown = candidateSolution;
            }
        }

        return index;

    } // indexBest

    /**
     * Returns the best Solution using a <code>Comparator</code>. If there are
     * more than one occurrences, only the first one is returned
     *
     * @param comparator <code>Comparator</code> used to compare solutions.
     * @return The best Solution attending to the comparator or <code>null<code>
     * if the SolutionSet is empty
     */
    public Solution best(Comparator<Solution> comparator) {
        int indexBest = indexBest(comparator);
        if (indexBest < 0) {
            return null;
        } else {
            return solutions.get(indexBest);
        }

    } // best

    /**
     * Returns the index of the worst Solution using a <code>Comparator</code>.
     * If there are more than one occurrences, only the index of the first one
     * is returned
     *
     * @param comparator <code>Comparator</code> used to compare solutions.
     * @return The index of the worst Solution attending to the comparator or
     * <code>-1<code> if the SolutionSet is empty
     */
    public int indexWorst(Comparator<Solution> comparator) {

        if ((solutions == null) || (this.solutions.isEmpty())) {
            return -1;
        }

        int index = 0;
        Solution worstKnown = solutions.get(0), candidateSolution;
        int flag;
        for (int i = 1; i < solutions.size(); i++) {
            candidateSolution = solutions.get(i);
            flag = comparator.compare(worstKnown, candidateSolution);
            if (flag == -1) {
                index = i;
                worstKnown = candidateSolution;
            }
        }

        return index;

    } // indexWorst

    /**
     * Returns the worst Solution using a <code>Comparator</code>. If there are
     * more than one occurrences, only the first one is returned
     *
     * @param comparator <code>Comparator</code> used to compare solutions.
     * @return The worst Solution attending to the comparator or
     * <code>null<code>
     * if the SolutionSet is empty
     */
    public Solution worst(Comparator<Solution> comparator) {

        int index = indexWorst(comparator);
        if (index < 0) {
            return null;
        } else {
            return solutions.get(index);
        }

    } // worst

    /**
     * Returns the number of solutions in the SolutionSet.
     *
     * @return The size of the SolutionSet.
     */
    public int size() {
        return solutions.size();
    } // size

    /**
     * Empties the SolutionSet
     */
    public void clear() {
        solutions.clear();
    } // clear

    /**
     * Deletes the <code>Solution</code> at position i in the set.
     *
     * @param i The position of the solution to remove.
     */
    public void remove(int i) {
        if (i > solutions.size() - 1) {
            Configuration.logger_.severe("Size is: " + this.size());
        } // if
        solutions.remove(i);
    } // remove

    /**
     * Returns an <code>Iterator</code> to access to the solution set list.
     *
     * @return the <code>Iterator</code>.
     */
    public Iterator<Solution> iterator() {
        return solutions.iterator();
    } // iterator

    /**
     * Returns a new <code>SolutionSet</code> which is the result of the union
     * between the current solution set and the one passed as a parameter.
     *
     * @param solutionSet SolutionSet to join with the current solutions.
     * @return The result of the union operation.
     */
    public SolutionSet union(SolutionSet solutionSet) {
        // Check the correct size. In development
        int newSize = this.size() + solutions.size();
        if (newSize < capacity_)
            newSize = capacity_;

        // Create a new population
        SolutionSet union = new SolutionSet(newSize);
        for (int i = 0; i < this.size(); i++) {
            union.add(this.get(i));
        } // for

        for (int i = this.size(); i < (this.size() + solutions.size()); i++) {
            union.add(solutions.get(i - this.size()));
        } // for

        return union;
    } // union

    /**
     * Replaces a solution by a new one
     *
     * @param position The position of the solution to replace
     * @param solution The new solution
     */
    public void replace(int position, Solution solution) {
        if (position > this.solutions.size()) {
            solutions.add(solution);
        } // if
        solutions.remove(position);
        solutions.add(position, solution);
    } // replace

    public List<Solution> getSolutionSet() {
        return this.solutions;
    }

    public void setSolutionSet(List<Solution> solutions) {
        this.solutions = solutions;
    }

    /**
     * Copies the objectives of the solution set to a matrix
     *
     * @return A matrix containing the objectives
     */
    public double[][] writeObjectivesToMatrix() {
        if (this.size() == 0) {
            return null;
        }
        double[][] objectives;
        objectives = new double[size()][get(0).numberOfObjectives()];
        for (int i = 0; i < size(); i++) {
            for (int j = 0; j < get(0).numberOfObjectives(); j++) {
                objectives[i][j] = get(i).getObjective(j);
            }
        }
        return objectives;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SolutionSet that = (SolutionSet) o;
        return capacity_ == that.capacity_ && Objects.equals(solutions, that.solutions);
    }

    @Override
    public int hashCode() {
        return Objects.hash(solutions, capacity_);
    }





    /**
     * Copies the objectives and Elements Number of the solution set to a matrix
     * Objectives, nrClasses, nrConcerns, nrInterfaces, nrPackages, nrVariationPoints, nrVariants, nrVariabilities, nrConcerns,
     * nrAbstractions, nrAggregation, nrAssociations, nrCompositions, nrDependencies, nrGeneralizations, nrRealizations, nrUsage
     *
     * @return matrix containing the objectives
     */
    public double[][] writeObjectivesAndElementsNumberToMatrix() {
        double[][] doubles = writeObjectivesToMatrix();
        for (int i = 0; i < doubles.length; i++) {
            int length = doubles[i].length;
            double[] doublesObj = new double[length + 4 + 3];
            System.arraycopy(doubles[i], 0, doublesObj, 0, doubles[i].length);
            doublesObj[length] = solutions.get(i).getAlternativeArchitecture().getAllClasses().size();
            doublesObj[length + 1] = solutions.get(i).getAlternativeArchitecture().getAllConcerns().size();
            doublesObj[length + 2] = solutions.get(i).getAlternativeArchitecture().getAllInterfaces().size();
            doublesObj[length + 3] = solutions.get(i).getAlternativeArchitecture().getAllPackages().size();
            doublesObj[length + 4] = solutions.get(i).getAlternativeArchitecture().getAllVariationPoints().size();
            doublesObj[length + 5] = solutions.get(i).getAlternativeArchitecture().getAllVariants().size();
            doublesObj[length + 6] = solutions.get(i).getAlternativeArchitecture().getAllVariabilities().size();
            doubles[i] = doublesObj;
        }
        return doubles;
    } // writeObjectivesAndElementsNumberToMatrix

    /**
     * Copies the objectives and Elements Number of the solution set to a matrix
     * Objectives, nrClasses, nrConcerns, nrInterfaces, nrPackages, nrVariationPoints, nrVariants, nrVariabilities, nrConcerns,
     * nrAbstractions, nrAggregations, nrAssociations, nrCompositions, nrDependencies, nrGeneralizations, nrRealizations, nrUsage
     *
     * @return matrix containing the objectives
     */
    public double[][] writeObjectivesAndArchitecturalElementsNumberToMatrix() {
        return reduceThreeDimensionalArray(getSolutionsWithArchitecturalEvaluations().stream()
                .map(this::writeObjectiveWithAllElementsFromSolution).toArray(double[][][]::new));
    }

    /**
     * Copies the objectives and All Elements of a specific set to a matrix
     *
     * @param solution specific solution
     * @return Matrix with values
     */
    private double[][] writeObjectiveWithAllElementsFromSolution(Solution solution) {
        double[] objectives = solution.getObjectives();
        double[][] values = writeAllElementsFromSolution(solution);
        double[][] newValues = new double[values.length][];
        int i = 0;
        for (double[] value : values) {
            double[] newArray = new double[objectives.length + value.length];
            System.arraycopy(objectives, 0, newArray, 0, objectives.length);
            System.arraycopy(value, 0, newArray, objectives.length, value.length);
            newValues[i] = newArray;
            i++;
        }
        return newValues;
    }

    /**
     * Generate the Solution from elements and get the objective values
     *
     * @param element  specific element to add in solution
     * @param solution specific solution
     * @return list of objectives
     */
    @Override
    public double[] writeObjectiveFromElementsAndObjectives(Element element, Solution solution) {
        Solution newSolution = null;
        try {
            newSolution = new Solution((Problem) solution.getProblem());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        OPLA.getLOGGER().setLevel(org.apache.log4j.Level.OFF);
        Architecture.getLOGGER().setLevel(org.apache.log4j.Level.OFF);
        Architecture architecture = new Architecture("pla");
        architecture.addElement(element);
        if (newSolution != null) {
            newSolution.setDecisionVariables(new Architecture[]{architecture});
            ((OPLA) newSolution.getProblem()).evaluate(newSolution);
            try {
                newSolution.getProblem().evaluateConstraints(newSolution);
            } catch (JMException e) {
                e.printStackTrace();
            }
            OPLA.getLOGGER().setLevel(org.apache.log4j.Level.ALL);
            Architecture.getLOGGER().setLevel(org.apache.log4j.Level.ALL);
            return newSolution.getObjectives();
        }
        return null;
    }

    /**
     * Copies the objectives and Elements Number of the solution set to a matrix
     * Objectives, nrClasses, nrConcerns, nrInterfaces, nrPackages, nrVariationPoints, nrVariants, nrVariabilities, nrConcerns,
     * nrAbstractions, nrAggregations, nrAssociations, nrCompositions, nrDependencies, nrGeneralizations, nrRealizations, nrUsage
     *
     * @return A matrix containing the objectives
     */
    public double[] writeArchitecturalEvaluationsToMatrix() {
        double[][] doubles = getSolutionsWithArchitecturalEvaluations().stream().map(solution -> {
            List<Element> allElementsFromSolution = getAllElementsFromSolution(solution);
            return allElementsFromSolution.stream().mapToDouble(element -> element.isFreezeByDM() ? 1.0 : 0.0).toArray();
        }).toArray(double[][]::new);
        return reduceBiDimensionalArray(doubles);
    }

    /**
     * Reduce one dimensional in three dimensional array
     *
     * @param treeDimensionalArray array of objectives
     * @return bi-dimensional array of objectives
     */
    public double[][] reduceThreeDimensionalArray(double[][][] treeDimensionalArray) {
        if (treeDimensionalArray.length <= 0) return new double[][]{};
        double[][] twoDimensionalArray = treeDimensionalArray[0];
        for (int i = 1; i < treeDimensionalArray.length; i++) {
            twoDimensionalArray = (double[][]) ArrayUtils.addAll(twoDimensionalArray, treeDimensionalArray[i]);
        }
        return twoDimensionalArray;
    }

    /**
     * Reduce one dimension from bi dimensional array
     *
     * @param biDimensionalArray array of objectives
     * @return one-dimensional array of objectives
     */
    public double[] reduceBiDimensionalArray(double[][] biDimensionalArray) {
        if (biDimensionalArray.length <= 0) return new double[]{};
        double[] oneDimensionalArray = biDimensionalArray[0];
        for (int i = 1; i < biDimensionalArray.length; i++) {
            oneDimensionalArray = ArrayUtils.addAll(oneDimensionalArray, biDimensionalArray[i]);
        }
        return oneDimensionalArray;
    }

    /**
     * Get all elements from solutions
     *
     * @param solution specific solution
     * @return array of elements
     */
    public double[][] writeAllElementsFromSolution(Solution solution) {
        List<Element> allElementsFromSolution = getAllElementsFromSolution(solution);
        return allElementsFromSolution.stream().map(s -> this.writeCharacteristicsFromElement(s, solution)).toArray(double[][]::new);
    }

    /**
     * Get characteristics from element in a solution (number id, element type, nr of classes, interfaces, attrs and methods, objectives, user evaluation)
     *
     * @param element  specific in a solution
     * @param solution specific solution
     * @return array of characteristics
     */
    public double[] writeCharacteristicsFromElement(Element element, Solution solution) {
        double[] elementProperties = new double[6];
        elementProperties[0] = element.getNumberId();
        elementProperties[1] = ArchitecturalElementType.getTypeId(element.getTypeElement());
        elementProperties[2] = element instanceof Package ? (double) ((Package) element).getAllClasses().size() : 0;
        elementProperties[3] = element instanceof Package ? (double) ((Package) element).getAllInterfaces().size() : 0;
        elementProperties[4] = element instanceof Class ? (double) ((Class) element).getAllAttributes().size() : 0;
        elementProperties[5] = element instanceof Class ? (double) ((Class) element).getAllMethods().size() :
                element instanceof Interface ? (double) ((Interface) element).getMethods().size() : 0;
        double[] doubles = writeObjectiveFromElementsAndObjectives(element, solution);
        elementProperties = ArrayUtils.addAll(elementProperties, doubles);
        elementProperties = ArrayUtils.addAll(elementProperties, new double[]{
                solution.containsArchitecturalEvaluation() ? 1 : 0
        });
        return elementProperties;
    }

    /**
     * Get all elements from solution
     *
     * @param solution specific solution
     * @return list of elements
     */
    public List<Element> getAllElementsFromSolution(Solution solution) {
        List<Element> elements = new ArrayList<>();
        elements.addAll(solution.getAlternativeArchitecture().getAllPackages());
        elements.addAll(solution.getAlternativeArchitecture().getAllClasses());
        elements.addAll(solution.getAlternativeArchitecture().getAllInterfaces());
        return elements;
    }

    /**
     * Method to get a string of objectives and elements number. Used to create CSV files
     *
     * @param startFrom Number of objectives
     * @return List of elements. If startFrom > 0, then specify the objectives number
     */
    public String toStringObjectivesAndElementsNumber(int startFrom) {
        return Arrays.stream(writeObjectivesAndElementsNumberToMatrix()).map(p -> Arrays
                .asList(ArrayUtils.toObject(Arrays.copyOfRange(p, startFrom, p.length))).toString()
                .replace("]", "\n").replace("[", "").replaceAll("\\.0", "")
                .replaceAll(" ", "")).collect(Collectors.joining());
    }

    /**
     * Create a list from objectives. Used to create CSV Files
     *
     * @param interaction interaction Number
     * @return list of objectives
     */
    public String toStringObjectives(String interaction) {
        return Arrays.stream(writeObjectivesToMatrix()).map(p -> Arrays.asList(ArrayUtils.toObject(p))
                .toString().replace("]", interaction + "," + interaction + "\n").replace(",", "|")
                .replace("[", interaction + "," + interaction + ",").replaceAll("\\.0", "")
                .replaceAll(" ", "")).collect(Collectors.joining());
    }

    /**
     * Get objectives and elements number with evaluation
     *
     * @return array of objectives with elements and user evaluation
     */
    public double[][] writeObjectivesAndElementsNumberEvaluationToMatrix() {
        double[][] doubles = writeObjectivesAndElementsNumberToMatrix();
        for (int i = 0; i < doubles.length; i++) {
            doubles[i] = Arrays.copyOf(doubles[i], doubles[i].length + 1);
            doubles[i][doubles[i].length - 1] = solutions.get(i).getEvaluation();
        }
        return doubles;
    }

    /**
     * Get user evaluations list
     *
     * @return array of user evaluations
     */
    public double[] writeUserEvaluationsToMatrix() {
        double[] doubles = new double[solutions.size()];
        for (int i = 0; i < solutions.size(); i++) {
            doubles[i] = solutions.get(i).getEvaluation();
        }
        return doubles;
    }

    /**
     * Verify if has user evaluation
     *
     * @return true if has. false if has'nt
     */
    public boolean hasUserEvaluation() {
        double[] doubles = writeUserEvaluationsToMatrix();
        for (double aDouble : doubles) {
            if (aDouble > 0) return true;
        }
        return false;
    }

    /**
     * Get list of cluster ids
     *
     * @return array of cluster ids
     */
    public Map<Double, Set<Integer>> getClusterIds() {
        Map<Double, Set<Integer>> clusters = new HashMap<>();
        for (Solution solution : solutions) {
            if (solution.getClusterId() != null) {
                Set<Integer> clusterId = clusters.getOrDefault(solution.getClusterId(), new HashSet<>());
                clusterId.add(solution.getEvaluation());
                clusters.put(solution.getClusterId(), clusterId);
            }
        }
        return clusters;
    }

    /**
     * Get average of values
     *
     * @param values values
     * @return average of values
     */
    public int getMedia(Set<Integer> values) {
        if (values == null) return 0;
        values = values.stream().filter(v -> v > 0).collect(Collectors.toSet());
        if (values.size() == 0) return 0;
        if (values.size() == 1) return values.stream().findFirst().get();
        int soma = 0;
        for (Integer value : values) {
            soma += value;
        }
        return soma / values.size();
    }


    @Override
    public List<Element> getArchitecturalElementsEvaluatedByClusterId(Double clusterId) {
        List<Element> elements = new ArrayList<>();
        List<List<Element>> collect = getSolutionsWithArchitecturalEvaluations().stream()
                .filter(solution -> clusterId.equals(solution.getClusterId()))
                .map(solution -> solution.getAllElements()
                        .stream().filter(Element::isFreezeByDM).collect(Collectors.toList())).collect(Collectors.toList());
        for (List<Element> elementList : collect) {
            elements.addAll(elementList);
        }
        return elements;
    }
    /**
     * Freeze the architectural elements according the solution
     *
     * @param solution solution with elements
     */
    @Override
    public void freezeArchitecturalElementsAccordingSolution(Solution solution) {
        List<Element> evaluatedElements = solution.getFreezedElements();
        if (evaluatedElements.size() > 0) {
            for (Solution aSolution : solutions) {
                List<MLElement> collect = aSolution.getAllElements().stream()
                        .filter(e -> evaluatedElements.stream().anyMatch(ee -> ee.totalyEquals(e))).collect(Collectors.toList());
                if (collect.size() > 0) {
                    for (MLElement element : collect) {
                        element.setFreezedByCluster();
                    }
                }
            }
        }
    }

    /**
     * Find elements with a id
     *
     * @param id hash id
     * @return filtered elements
     */
    public List<Element> findElementWithNumberId(Double id) {
        List<List<Element>> collect = solutions.stream().map(s -> s
                .findElementByNumberId(id)).collect(Collectors.toList());
        List<Element> objects = new ArrayList<>();
        for (List<Element> elements : collect) {
            objects.addAll(elements);
        }
        return objects;
    }

    /**
     * Save solution in a file
     *
     * @param solution specific solution
     * @param path     path
     */
    public void saveVariableToFile(Solution solution, String path) {
        int numberOfVariables = solution.getDecisionVariables().length;

        for (int j = 0; j < numberOfVariables; j++) {
            Architecture arch = (Architecture) solution.getDecisionVariables()[j];
            arch.setName(solution.getAlternativeArchitecture().getName());
            arch.save(arch, path, "");
        }
    }


    /**
     * Writes the objective function values of the <code>Solution</code> objects
     * into the set in a file.
     *
     * @param path The output file name
     */
    public void printObjectivesToFile(String path) {
        printObjectivesWithoutNormalizeToFile(path);
        printObjectivesWithHypervolumeToFile(path);
        printObjectivesNormalizedToFile(path);
        printQualityIndicators(path);
    }

    private void printObjectivesWithHypervolumeToFile(String pathNorm) {
        String path = pathNorm.replace("txt", "hypervolume");
        File file = new File(path);
        file.getParentFile().mkdirs();
        try {
            FileOutputStream fos = new FileOutputStream(path);
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            BufferedWriter bw = new BufferedWriter(osw);
            String executionId = solutions.get(0).getExecutionId();
            for (int i = 0; i < solutions.size(); i++) {
                bw.write(Arrays.toString(getNormalizedSolution(i)).trim().replaceAll("]", "")
                        .replaceAll("\\[", "").replaceAll(", ", "\t"));
                bw.newLine();
                if (executionId != null && !executionId.equals(solutions.get(i).getExecutionId())) {
                    executionId = solutions.get(i).getExecutionId();
                    bw.newLine();
                }
            }
            bw.close();
        } catch (IOException e) {
            Configuration.logger_.severe("Error acceding to the file");
            e.printStackTrace();
        }
    }

    private void printObjectivesNormalizedToFile(String pathNorm) {
        String path = pathNorm.replace("txt", "normalized");
        File file = new File(path);
        file.getParentFile().mkdirs();
        try {
            FileOutputStream fos = new FileOutputStream(path);
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            BufferedWriter bw = new BufferedWriter(osw);
            String executionId = solutions.get(0).getExecutionId();
            for (int i = 0; i < solutions.size(); i++) {
                bw.write(Arrays.toString(getNormalizedSolution(i)).trim().replaceAll("]", "").replaceAll("\\[", "").replaceAll(", ", "\t")); // returns something
                bw.newLine();
            }
            bw.close();
        } catch (IOException e) {
            Configuration.logger_.severe("Error acceding to the file");
            e.printStackTrace();
        }
    }

    private void printQualityIndicators(String pathInd) {
        String path = pathInd.replace("txt", "indicators");
        File file = new File(path);
        file.getParentFile().mkdirs();
        try {
            FileOutputStream fos = new FileOutputStream(path);
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            BufferedWriter bw = new BufferedWriter(osw);
            QualityIndicator qualityIndicator = new QualityIndicator(solutions.get(0).getProblem(), pathInd.replace("txt", "normalized"));
            bw.write("HV:" + qualityIndicator.getHypervolume(this));
            bw.newLine();
            bw.write("EPSILON:" + qualityIndicator.getEpsilon(this));
            bw.newLine();
            bw.write("IGD:" + qualityIndicator.getIGD(this));
            bw.newLine();
            bw.write("SPREAD:" + qualityIndicator.getSpread(this));
            bw.newLine();
            bw.write("GD:" + qualityIndicator.getGD(this));
            bw.newLine();

            bw.close();
        } catch (IOException e) {
            Configuration.logger_.severe("Error acceding to the file");
            e.printStackTrace();
        }
    }

    private void printObjectivesWithoutNormalizeToFile(String path) {
        File file = new File(path);
        file.getParentFile().mkdirs();
        try {
            FileOutputStream fos = new FileOutputStream(path);
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            BufferedWriter bw = new BufferedWriter(osw);

            for (int i = 0; i < solutions.size(); i++) {
                bw.write(solutions.get(i).toString().trim().replaceAll(" ", ", ")); // returns something
                bw.newLine();
            }
            bw.close();
        } catch (IOException e) {
            Configuration.logger_.severe("Error acceding to the file");
            e.printStackTrace();
        }
    }

    /**
     * Writes the decision variable values of the <code>Solution</code>
     * solutions objects into the set in a file.
     *
     * @param path The output file name
     */
    public void printVariablesToFile(String path) {
        try {
            FileOutputStream fos = new FileOutputStream(path);
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            BufferedWriter bw = new BufferedWriter(osw);

            int numberOfVariables = solutions.get(0).getDecisionVariables().length;
            for (int i = 0; i < solutions.size(); i++) {
                for (int j = 0; j < numberOfVariables; j++) {
                    bw.write(((Architecture) solutions.get(i).getDecisionVariables()[j]).getName());
                }
                bw.newLine();
            }

            bw.close();
        } catch (IOException e) {
            Configuration.logger_.severe("Error acceding to the file");
            e.printStackTrace();
        }
    } // printVariablesToFile

    /**
     * Save variables in a file
     *
     * @param path       path
     * @param funResults information of each solution
     * @param logger     logger
     * @param generate   log without save
     */
    public void saveVariablesToFile(String path, List<Info> funResults, LogLog logger, boolean generate) {
        int numberOfVariables = solutions.get(0).getDecisionVariables().length;
        SaveStringToFile.getInstance().createLogDir();
        String logPath = ApplicationFileConfigThreadScope.getDirectoryToExportModels() + FileConstants.FILE_SEPARATOR
                + "logs" + FileConstants.FILE_SEPARATOR + "link_fitness.txt";
        if (logger != null)
            logger.putLog("Number of solutions: " + solutions.size(), Level.INFO);
        for (int i = 0; i < solutions.size(); i++) {
            for (int j = 0; j < numberOfVariables; j++) {
                Architecture arch = (Architecture) solutions.get(i).getDecisionVariables()[j];
                String pathToSave = path;
                String originalName = ((OPLA) solutions.get(i).getProblem()).getArchitecture_().getName();
                funResults.get(i).setName(pathToSave + originalName);
                if (generate) {
                    if (funResults.get(i).getId() == null) funResults.get(i).setId(funResults.get(i).getObjectives()
                            .replace("|", "-") + "-" + RandomStringUtils.randomNumeric(3));
                    arch.save(arch, pathToSave, "-" + funResults.get(i).getId());
                    SaveStringToFile.getInstance().appendStrToFile(logPath, "\n" + pathToSave + arch.getName()
                            + funResults.get(i).getId() + "\t" + solutions.get(i).toString());
                }
            }
        }
    }

    public void saveVariablesToFile(String path) {
        int numberOfVariables = solutions.get(0).getDecisionVariables().length;
        System.out.println("Number of solutions: " + solutions.size());
        for (int i = 0; i < solutions.size(); i++) {
            for (int j = 0; j < numberOfVariables; j++) {
                Architecture arch = (Architecture) solutions.get(i).getDecisionVariables()[j];
                String pathToSave = path;
                arch.save(arch, pathToSave, String.valueOf(i));
            }
        }
    }

    public double[] getNormalizedSolution(int i) {
        Solution solution = solutions.get(i);
        Solution max = getMax();
        Solution min = getMin();
        double[] doubles = new double[solution.getObjectives().length];
        if (solutions.size() == 1) return doubles;
        for (int j = 0; j < solution.getObjectives().length; j++) {
            doubles[j] = (max.getObjective(j) - min.getObjective(j)) == 0 ? 0 :
                    (solution.getObjective(j) - min.getObjective(j)) / (max.getObjective(j) - min.getObjective(j));
            if (doubles[j] == -0.0) doubles[j] = 0.0;
        }
        return doubles;
    }

    @JsonIgnore
    public Solution getMin() {
        Solution solution = solutions.get(0);
        for (int i = 0; i < solution.getObjectives().length; i++) {
            for (Solution otherSolution : solutions) {
                if (otherSolution.getObjective(i) <= solution.getObjective(i)) {
                    solution = otherSolution;
                }
            }
        }
        return solution;
    }

    @JsonIgnore
    public Solution getMax() {
        Solution solution = solutions.get(0);
        for (int i = 0; i < solution.getObjectives().length; i++) {
            for (Solution otherSolution : solutions) {
                if (otherSolution.getObjective(i) >= solution.getObjective(i)) {
                    solution = otherSolution;
                }
            }
        }
        return solution;
    }

    public List<Solution> getSolutions() {
        return solutions;
    }

    @Override
    @JsonIgnore
    public List<Solution> getSolutionsWithArchitecturalEvaluations() {
        return super.getSolutionsWithArchitecturalEvaluations();
    }
}
package br.otimizes.oplatool.core.jmetal4.experiments;

import br.otimizes.oplatool.architecture.builders.ArchitectureBuilders;
import br.otimizes.oplatool.core.jmetal4.operators.MutationOperators;
import br.otimizes.isearchai.learning.ClusteringAlgorithm;
import br.otimizes.isearchai.learning.Moment;
import br.otimizes.oplatool.patterns.strategies.scopeselection.impl.ElementsWithSameDesignPatternSelection;
import br.ufpr.dinf.gres.loglog.LogLog;
import interactive.InteractiveFunction;
import org.apache.commons.lang.WordUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public abstract class ExperimentCommonConfigs {

    private boolean log = false;
    private LogLog logger;
    private String pathToDb;
    private int numberOfRuns;
    private int maxEvaluations;
    private double crossoverProbability;
    private double mutationProbability;
    private String plas;
    private OPLAConfigs oplaConfigs;
    private String[] patterns = null;
    private String description;
    private InteractiveFunction interactiveFunction;
    private Boolean interactive;
    private int maxInteractions;
    private int firstInteraction;
    private int intervalInteraction;
    private ArchitectureBuilders architectureBuilder = ArchitectureBuilders.SMARTY;
    private Moment clusteringMoment;
    private ClusteringAlgorithm clusteringAlgorithm;
    private List<String> mutationOperators = new ArrayList<>();
    private List<String> crossoverOperators = new ArrayList<>();
    private ElementsWithSameDesignPatternSelection applyStrategy;

    public void activeLogs() {
        log = true;
    }

    public String getPlas() {
        return this.plas;
    }

    public void setPlas(String plas) {
        this.plas = plas;
    }

    public int getNumberOfRuns() {
        return numberOfRuns;
    }

    public void setNumberOfRuns(int numberOfRuns) {
        validateGreaterOrEqualOne("numberOfRuns", numberOfRuns);
        this.numberOfRuns = numberOfRuns;
    }

    public int getMaxEvaluation() {
        return maxEvaluations;
    }

    public void setMaxEvaluations(int maxEvaluations) {
        validateGreaterOrEqualOne("maxEvaluation", maxEvaluations);
        this.maxEvaluations = maxEvaluations;
    }

    protected void validateArgument(String arg, double probability) {
        if (probability < 0 || probability > 1) {
            throw new IllegalArgumentException(arg + " must be a value between 0 and 1");
        }
    }

    public double getCrossoverProbability() {
        return this.crossoverProbability;
    }

    public void setCrossoverProbability(double crossoverProbability) {
        validateArgument("crossoverProbability", crossoverProbability);
        this.crossoverProbability = crossoverProbability;
    }

    public double getMutationProbability() {
        return mutationProbability;
    }

    public void setMutationProbability(double mutationProbability) {
        validateArgument("mutationProbability", mutationProbability);
        this.mutationProbability = mutationProbability;
    }

    public void disableCrossover() {
        this.crossoverProbability = 0;
    }

    public void disableMutation() {
        this.mutationProbability = 0;
    }

    public List<String> getMutationOperators() {
        return mutationOperators;
    }

    public void setMutationOperators(List<String> mutationOperators) {
        this.mutationOperators = mutationOperators;
    }

    public OPLAConfigs getOplaConfigs() {
        return oplaConfigs;
    }

    public void setOplaConfigs(OPLAConfigs oplaConfigs) {
        this.oplaConfigs = oplaConfigs;
    }

    /**
     * Get Design Patterns to apply. If none is set return all.
     *
     * @return String[]
     */
    public String[] getPatterns() {
        if (patterns == null) {
            return new String[]{"Strategy", "Bridge", "Mediator"};
        }
        return patterns;
    }

    public void setPatterns(String... patternsList) {
        for (int i = 0; i < patternsList.length; i++) {
            patternsList[i] = WordUtils.capitalize(patternsList[i].toLowerCase());
        }
        this.patterns = patternsList;

        if (Collections.disjoint(Arrays.asList(this.patterns), Arrays.asList("Strategy", "Bridge", "Mediator"))) {
            throw new IllegalArgumentException("Invalid(s) Design Pattern(s). Valid are: Strategy, Bridge and Mediator");
        }
    }

    public ElementsWithSameDesignPatternSelection getDesignPatternStrategy() {
        return applyStrategy;
    }

    public void setDesignPatternStrategy(ElementsWithSameDesignPatternSelection elementsWithSameDesignPatternSelection) {
        this.applyStrategy = elementsWithSameDesignPatternSelection;
    }

    public boolean isLog() {
        return log && logger != null;
    }

    public String getPathToDb() {
        return pathToDb;
    }

    public void setPathToDb(String pathToDb) {
        this.pathToDb = pathToDb;
    }

    public void excludeDesignPatternsFromMutationOperatorList() {
        this.getMutationOperators().remove(MutationOperators.DESIGN_PATTERNS.toString());
    }

    protected void validateGreaterOrEqualOne(String arg, int numberOfRuns) {
        if (numberOfRuns < 1) {
            throw new IllegalArgumentException(arg + " must be greater or equal 1");
        }
    }

    public LogLog getLogger() {
        return logger;
    }

    public void setLogger(LogLog logLog) {
        this.logger = logLog;
    }

    public String getDescription() {
        return description;
    }

    public int getIntervalInteraction() {
        return intervalInteraction;
    }

    public void setIntervalInteraction(Integer intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public List<String> getObjectiveFunctions() {
        return oplaConfigs.getSelectedObjectiveFunctions();
    }

    public Boolean getInteractive() {
        return interactive != null && interactive;
    }

    public void setInteractive(Boolean interactive) {
        this.interactive = interactive;
    }

    public InteractiveFunction getInteractiveFunction() {
        return interactiveFunction;
    }

    public void setInteractiveFunction(InteractiveFunction interactiveFunction) {
        this.interactiveFunction = interactiveFunction;
    }

    public void setLog(boolean log) {
        this.log = log;
    }

    public int getMaxEvaluations() {
        return maxEvaluations;
    }

    public int getMaxInteractions() {
        return maxInteractions;
    }

    public void setMaxInteractions(int maxInteractions) {
        this.maxInteractions = maxInteractions;
    }

    public int getFirstInteraction() {
        return firstInteraction;
    }

    public void setFirstInteraction(int firstInteraction) {
        this.firstInteraction = firstInteraction;
    }

    public ElementsWithSameDesignPatternSelection getApplyStrategy() {
        return applyStrategy;
    }

    public void setApplyStrategy(ElementsWithSameDesignPatternSelection applyStrategy) {
        this.applyStrategy = applyStrategy;
    }

    public ClusteringAlgorithm getClusteringAlgorithm() {
        return clusteringAlgorithm != null ? clusteringAlgorithm : ClusteringAlgorithm.KMEANS;
    }

    public void setClusteringAlgorithm(ClusteringAlgorithm clusteringAlgorithm) {
        this.clusteringAlgorithm = clusteringAlgorithm;
    }

    public Moment getClusteringMoment() {
        return clusteringMoment;
    }

    public void setClusteringMoment(Moment clusteringMoment) {
        this.clusteringMoment = clusteringMoment;
    }

    public ArchitectureBuilders getArchitectureBuilder() {
        return architectureBuilder;
    }

    public void setArchitectureBuilder(ArchitectureBuilders architectureBuilder) {
        this.architectureBuilder = architectureBuilder;
    }

    public List<String> getCrossoverOperators() {
        return crossoverOperators;
    }

    public void setCrossoverOperators(List<String> crossoverOperators) {
        this.crossoverOperators = crossoverOperators;
    }

    public void setIntervalInteraction(int intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }
}
package br.otimizes.oplatool.core.jmetal4.experiments;

import br.otimizes.oplatool.architecture.builders.ArchitectureBuilders;
import br.otimizes.oplatool.core.jmetal4.operators.MutationOperators;
import br.otimizes.isearchai.learning.ClusteringAlgorithm;
import br.otimizes.isearchai.learning.Moment;
import br.otimizes.oplatool.patterns.strategies.scopeselection.impl.ElementsWithSameDesignPatternSelection;
import br.ufpr.dinf.gres.loglog.LogLog;
import interactive.InteractiveFunction;
import org.apache.commons.lang.WordUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public abstract class ExperimentCommonConfigs {

    private boolean log = false;
    private LogLog logger;
    private String pathToDb;
    private int numberOfRuns;
    private int maxEvaluations;
    private double crossoverProbability;
    private double mutationProbability;
    private String plas;
    private OPLAConfigs oplaConfigs;
    private String[] patterns = null;
    private String description;
    private InteractiveFunction interactiveFunction;
    private Boolean interactive;
    private int maxInteractions;
    private int firstInteraction;
    private int intervalInteraction;
    private ArchitectureBuilders architectureBuilder = ArchitectureBuilders.SMARTY;
    private Moment clusteringMoment;
    private ClusteringAlgorithm clusteringAlgorithm;
    private List<String> mutationOperators = new ArrayList<>();
    private List<String> crossoverOperators = new ArrayList<>();
    private ElementsWithSameDesignPatternSelection applyStrategy;

    public void activeLogs() {
        log = true;
    }

    public String getPlas() {
        return this.plas;
    }

    public void setPlas(String plas) {
        this.plas = plas;
    }

    public int getNumberOfRuns() {
        return numberOfRuns;
    }

    public void setNumberOfRuns(int numberOfRuns) {
        validateGreaterOrEqualOne("numberOfRuns", numberOfRuns);
        this.numberOfRuns = numberOfRuns;
    }

    public int getMaxEvaluation() {
        return maxEvaluations;
    }

    public void setMaxEvaluations(int maxEvaluations) {
        validateGreaterOrEqualOne("maxEvaluation", maxEvaluations);
        this.maxEvaluations = maxEvaluations;
    }

    protected void validateArgument(String arg, double probability) {
        if (probability < 0 || probability > 1) {
            throw new IllegalArgumentException(arg + " must be a value between 0 and 1");
        }
    }

    public double getCrossoverProbability() {
        return this.crossoverProbability;
    }

    public void setCrossoverProbability(double crossoverProbability) {
        validateArgument("crossoverProbability", crossoverProbability);
        this.crossoverProbability = crossoverProbability;
    }

    public double getMutationProbability() {
        return mutationProbability;
    }

    public void setMutationProbability(double mutationProbability) {
        validateArgument("mutationProbability", mutationProbability);
        this.mutationProbability = mutationProbability;
    }

    public void disableCrossover() {
        this.crossoverProbability = 0;
    }

    public void disableMutation() {
        this.mutationProbability = 0;
    }

    public List<String> getMutationOperators() {
        return mutationOperators;
    }

    public void setMutationOperators(List<String> mutationOperators) {
        this.mutationOperators = mutationOperators;
    }

    public OPLAConfigs getOplaConfigs() {
        return oplaConfigs;
    }

    public void setOplaConfigs(OPLAConfigs oplaConfigs) {
        this.oplaConfigs = oplaConfigs;
    }

    /**
     * Get Design Patterns to apply. If none is set return all.
     *
     * @return String[]
     */
    public String[] getPatterns() {
        if (patterns == null) {
            return new String[]{"Strategy", "Bridge", "Mediator"};
        }
        return patterns;
    }

    public void setPatterns(String... patternsList) {
        for (int i = 0; i < patternsList.length; i++) {
            patternsList[i] = WordUtils.capitalize(patternsList[i].toLowerCase());
        }
        this.patterns = patternsList;

        if (Collections.disjoint(Arrays.asList(this.patterns), Arrays.asList("Strategy", "Bridge", "Mediator"))) {
            throw new IllegalArgumentException("Invalid(s) Design Pattern(s). Valid are: Strategy, Bridge and Mediator");
        }
    }

    public ElementsWithSameDesignPatternSelection getDesignPatternStrategy() {
        return applyStrategy;
    }

    public void setDesignPatternStrategy(ElementsWithSameDesignPatternSelection elementsWithSameDesignPatternSelection) {
        this.applyStrategy = elementsWithSameDesignPatternSelection;
    }

    public boolean isLog() {
        return log && logger != null;
    }

    public String getPathToDb() {
        return pathToDb;
    }

    public void setPathToDb(String pathToDb) {
        this.pathToDb = pathToDb;
    }

    public void excludeDesignPatternsFromMutationOperatorList() {
        this.getMutationOperators().remove(MutationOperators.DESIGN_PATTERNS.toString());
    }

    protected void validateGreaterOrEqualOne(String arg, int numberOfRuns) {
        if (numberOfRuns < 1) {
            throw new IllegalArgumentException(arg + " must be greater or equal 1");
        }
    }

    public LogLog getLogger() {
        return logger;
    }

    public void setLogger(LogLog logLog) {
        this.logger = logLog;
    }

    public String getDescription() {
        return description;
    }

    public int getIntervalInteraction() {
        return intervalInteraction;
    }

    public void setIntervalInteraction(Integer intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public List<String> getObjectiveFunctions() {
        return oplaConfigs.getSelectedObjectiveFunctions();
    }

    public Boolean getInteractive() {
        return interactive != null && interactive;
    }

    public void setInteractive(Boolean interactive) {
        this.interactive = interactive;
    }

    public InteractiveFunction getInteractiveFunction() {
        return interactiveFunction;
    }

    public void setInteractiveFunction(InteractiveFunction interactiveFunction) {
        this.interactiveFunction = interactiveFunction;
    }

    public void setLog(boolean log) {
        this.log = log;
    }

    public int getMaxEvaluations() {
        return maxEvaluations;
    }

    public int getMaxInteractions() {
        return maxInteractions;
    }

    public void setMaxInteractions(int maxInteractions) {
        this.maxInteractions = maxInteractions;
    }

    public int getFirstInteraction() {
        return firstInteraction;
    }

    public void setFirstInteraction(int firstInteraction) {
        this.firstInteraction = firstInteraction;
    }

    public ElementsWithSameDesignPatternSelection getApplyStrategy() {
        return applyStrategy;
    }

    public void setApplyStrategy(ElementsWithSameDesignPatternSelection applyStrategy) {
        this.applyStrategy = applyStrategy;
    }

    public ClusteringAlgorithm getClusteringAlgorithm() {
        return clusteringAlgorithm != null ? clusteringAlgorithm : ClusteringAlgorithm.KMEANS;
    }

    public void setClusteringAlgorithm(ClusteringAlgorithm clusteringAlgorithm) {
        this.clusteringAlgorithm = clusteringAlgorithm;
    }

    public Moment getClusteringMoment() {
        return clusteringMoment;
    }

    public void setClusteringMoment(Moment clusteringMoment) {
        this.clusteringMoment = clusteringMoment;
    }

    public ArchitectureBuilders getArchitectureBuilder() {
        return architectureBuilder;
    }

    public void setArchitectureBuilder(ArchitectureBuilders architectureBuilder) {
        this.architectureBuilder = architectureBuilder;
    }

    public List<String> getCrossoverOperators() {
        return crossoverOperators;
    }

    public void setCrossoverOperators(List<String> crossoverOperators) {
        this.crossoverOperators = crossoverOperators;
    }

    public void setIntervalInteraction(int intervalInteraction) {
        this.intervalInteraction = intervalInteraction;
    }
}



